<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcript Storage Performance POC</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.8rem;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .approaches {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .approach {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .approach:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .approach.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .approach h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .approach p {
            opacity: 0.9;
            line-height: 1.6;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4a5568;
        }

        .control-group input, .control-group select {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .chart-container {
            position: relative;
            height: 400px;
        }

        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .performance-table th,
        .performance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .performance-table th {
            background: #f7fafc;
            font-weight: bold;
            color: #4a5568;
        }

        .performance-table tr:hover {
            background: #f7fafc;
        }

        .medal {
            font-size: 1.2rem;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #4a5568;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: #4a5568;
        }

        .stat-card h4 {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .test-results {
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .test-results h3 {
            color: #4a5568;
            margin-bottom: 15px;
        }

        .test-result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-result-item:last-child {
            border-bottom: none;
        }

        .test-result-label {
            font-weight: bold;
            color: #4a5568;
        }

        .test-result-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .winner-tables-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .winner-section {
            background: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .winner-section:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }

        .winner-table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        .winner-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .winner-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 12px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .winner-table th:last-child {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .header-subtitle {
            font-size: 0.8rem;
            font-weight: normal;
            opacity: 0.9;
            display: block;
            margin-top: 3px;
            line-height: 1.2;
        }

        .winner-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
            font-size: 1rem;
            vertical-align: middle;
            min-width: 80px;
        }

        .winner-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }

        .winner-table tbody tr:hover {
            background-color: #e6fffa;
            transform: scale(1.01);
            transition: all 0.2s ease;
        }

        .winner-cell:hover, .loser-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
        }

        .margin-cell:hover {
            transform: scale(1.02);
            box-shadow: 0 3px 10px rgba(72, 187, 120, 0.4);
            transition: all 0.2s ease;
        }

        .winner-table tbody tr:first-child td {
            font-weight: bold;
            color: #4a5568;
            background-color: #f7fafc;
        }

        .winner-cell {
            background: linear-gradient(135deg, #c6f6d5 0%, #9ae6b4 100%);
            color: #22543d;
            font-weight: bold;
            border: 2px solid #48bb78;
            border-radius: 6px;
            animation: bounceIn 0.6s ease;
        }

        .loser-cell {
            background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
            color: #742a2a;
            font-weight: bold;
            border: 2px solid #e53e3e;
            border-radius: 6px;
        }

        .neutral {
            color: #718096;
            font-size: 1.2rem;
        }

        .neutral::before {
            content: "—";
        }

        .margin-cell {
            background: linear-gradient(135deg, #f0fff4 0%, #e6fffa 100%);
            font-weight: bold;
            color: #2f855a;
            border-left: 3px solid #48bb78;
            text-align: center;
            font-size: 1.1rem;
        }

        .margin-cell.winner {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            color: #22543d;
            box-shadow: 0 2px 8px rgba(72, 187, 120, 0.3);
        }



        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .comparison-toggle {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .comparison-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .comparison-toggle.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        @media (max-width: 768px) {
            .results {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .winner-tables-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .winner-table th:last-child,
            .winner-table td:last-child {
                display: none; /* Hide margin column on mobile for space */
            }
            
            .winner-table th,
            .winner-table td {
                padding: 8px 6px;
                font-size: 0.9rem;
            }
            
            .winner-table th {
                font-size: 1rem;
            }
            
            .header-subtitle {
                font-size: 0.7rem;
                margin-top: 2px;
            }
            
            .winner-cell, .loser-cell {
                font-size: 0.9rem;
                padding: 8px 6px;
            }
            
            .margin-cell {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><img src="public/cliq.png" alt="Cliq" style="width: 100px; height: 100px; vertical-align: middle; display: inline-block;"> Transcript Caching - Storage Performance POC</h1>
            <p>Comparing Two IndexedDB Storage Approaches</p>
        </div>

        <div class="card">
            <h2>📊 Storage Approaches</h2>
            <div class="approaches">
                <div class="approach selected">
                    <h3>Way 1: Single Store (Main Thread)</h3>
                    <p>One store with chatId as key and map of message objects as value. Each message object has msguid as key and contains full message data. All operations run on the main thread.</p>
                </div>
                <div class="approach selected">
                    <h3>Way 2: Two Stores (Main Thread)</h3>
                    <p>Transcript store (chid vs msguid map) and message store (msguid vs message object). All operations run on the main thread.</p>
                </div>
                <div class="approach selected">
                    <h3>Way 3: Way 1 + Web Worker</h3>
                    <p>Same as Way 1 ( one store ) but all IDB  operations go through Web Worker.</p>
                </div>
                                  <div class="approach selected">
                      <h3>Way 4: Way 2 + Web Worker</h3>
                      <p>Same as Way 2 ( two stores ) but all IDB operations go through Web Worker. .</p>
                  </div>
                  <div class="approach" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); border: 2px solid #d63031;">
                      <h3>Way 5: One Store per Chat (Not Recommended)</h3>
                      <p style="color: #fff; font-weight: 500;">Creates a new store for each chat. <strong>Not implemented due to technical limitations:</strong></p>
                      <ul style="color: #fff; font-size: 0.9em; margin: 10px 0; padding-left: 20px;">
                          <li><strong>Version Upgrade Required:</strong> Each new chat needs DB version bump</li>
                          <li><strong>Tab Blocking:</strong> Each new Upgrades block other tabs, causing disruptions</li>
                          <li><strong>Performance Overhead:</strong> Many stores slow DB open and increase memory</li>
                          <li><strong>Maintenance Complexity:</strong> Dynamic store management and upgrade paths</li>
                      </ul>
                      <p style="color: #fff; font-size: 0.9em; margin-top: 10px; font-style: italic;">❌ <strong>Not suitable</strong></p>
                  </div>
              </div>
              <p style="text-align: center; margin-top: 20px; font-weight: bold; color: #667eea;">All four approaches will be tested automatically and compared!</p>
        
        </div>

        <div class="card">
            <h2>⚙️ Test Configuration</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="numChats">Number of Chats:</label>
                    <input type="number" id="numChats" value="50" min="1" max="10000">
                </div>
                <div class="control-group">
                    <label for="messagesPerChat">Messages per Chat:</label>
                    <input type="number" id="messagesPerChat" value="50" min="10" max="1000">
                </div>
                <div class="control-group">
                    <label for="messagesToLoad">Messages to Show On Opening Chat:</label>
                    <input type="number" id="messagesToLoad" value="50" min="1" max="1000" placeholder="Default: 40">
                </div>
                <div class="control-group">
                    <label for="testOperations">Test Operations:</label>
                    <select id="testOperations">
                        <option value="all">All Operations (Bulk + Single)</option>
                        <option value="bulk">Bulk Operations Only</option>
                        <option value="single">Single Operations Only</option>
                        <option value="read">Read Operations Only</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="clearPreviousDB" checked style="margin: 0; cursor: pointer;">
                        <span>Clear Previous Way Database</span>
                    </label>
                    <small style="color: #666; margin-top: 4px; display: block;">
                         <strong>Recommended:</strong> Ensures fair performance comparison by starting each way with a clean slate. 
                    </small>
                </div>

            </div>
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <button class="btn" onclick="runTest()" id="runBtn">🚀 Run Performance Test</button>
            </div>
        </div>

        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <h3>Running Test...</h3>
            <p>This may take a few minutes depending on the test size.</p>
        </div>

        <div id="results" style="display: none;">
            <div class="card">
                <h2>📊 Performance Comparison Chart (Time taken in main thread and worker thread combined)</h2>
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>📊 Performance Comparison Chart (Time taken in main thread only)</h2>
                <div class="chart-container">
                    <canvas id="mainThreadChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>🏆 Winner Comparison Tables</h2>
                <div class="winner-tables-grid">
                    <!-- Overall Performance Section (Total Time) -->
                    <div class="winner-section">
                        <h3 style="text-align: center; color: #667eea; margin-bottom: 15px;">🏆 Overall Performance Winners (Main Thread Time + Worker Thread Time Combined)</h3>
                        <div class="winner-table-container">
                            <table class="winner-table" id="overallPerformanceTable">
                                <thead>
                                    <tr>
                                        <th>Category</th>
                                        <th>Way 1<br><span class="header-subtitle">(One Store)</span></th>
                                        <th>Way 2<br><span class="header-subtitle">(Two Stores)</span></th>
                                        <th>Way 3<br><span class="header-subtitle">(One Store + Worker)</span></th>
                                        <th>Way 4<br><span class="header-subtitle">(Two Stores + Worker)</span></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Bulk Add Message</td>
                                        <td id="overall_bulkAdd_way1">-</td>
                                        <td id="overall_bulkAdd_way2">-</td>
                                        <td id="overall_bulkAdd_way3">-</td>
                                        <td id="overall_bulkAdd_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Add Message</td>
                                        <td id="overall_singleAdd_way1">-</td>
                                        <td id="overall_singleAdd_way2">-</td>
                                        <td id="overall_singleAdd_way3">-</td>
                                        <td id="overall_singleAdd_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Bulk Update Message</td>
                                        <td id="overall_bulkUpdate_way1">-</td>
                                        <td id="overall_bulkUpdate_way2">-</td>
                                        <td id="overall_bulkUpdate_way3">-</td>
                                        <td id="overall_bulkUpdate_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Update Message</td>
                                        <td id="overall_singleUpdate_way1">-</td>
                                        <td id="overall_singleUpdate_way2">-</td>
                                        <td id="overall_singleUpdate_way3">-</td>
                                        <td id="overall_singleUpdate_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Delete Message</td>
                                        <td id="overall_singleDelete_way1">-</td>
                                        <td id="overall_singleDelete_way2">-</td>
                                        <td id="overall_singleDelete_way3">-</td>
                                        <td id="overall_singleDelete_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Get Chat Messages</td>
                                        <td id="overall_getChat_way1">-</td>
                                        <td id="overall_getChat_way2">-</td>
                                        <td id="overall_getChat_way3">-</td>
                                        <td id="overall_getChat_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Get Chat Messages By Index Range</td>
                                        <td id="overall_getChatIndex_way1">-</td>
                                        <td id="overall_getChatIndex_way2">-</td>
                                        <td id="overall_getChatIndex_way3">-</td>
                                        <td id="overall_getChatIndex_way4">-</td>
                                    </tr>
                                    <tr>
                                        <td>Check Message Exists</td>
                                        <td id="overall_checkExists_way1">-</td>
                                        <td id="overall_checkExists_way2">-</td>
                                        <td id="overall_checkExists_way3">-</td>
                                        <td id="overall_checkExists_way4">-</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- UI Responsiveness Section (Main Thread Only) -->
                    <div class="winner-section">
                        <h3 style="text-align: center; color: #f093fb; margin-bottom: 15px;">🏆 UI Responsiveness Winners (Main Thread Time Only)</h3>
                        <div class="winner-table-container">
                            <table class="winner-table" id="uiResponsivenessTable">
                                <thead>
                                    <tr>
                                        <th>Category</th>
                                        <th>Way 1<br><span class="header-subtitle">(One Store)</span></th>
                                        <th>Way 2<br><span class="header-subtitle">(Two Stores)</span></th>
                                        <th>Way 3<br><span class="header-subtitle">(One Store + Worker)</span></th>
                                        <th>Way 4<br><span class="header-subtitle">(Two Stores + Worker)</span></th>
                                        <th>UI Responsiveness Gain<br><span class="header-subtitle">(% less main thread blocking)</span></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Bulk Add Message</td>
                                        <td id="ui_bulkAdd_way1">-</td>
                                        <td id="ui_bulkAdd_way2">-</td>
                                        <td id="ui_bulkAdd_way3">-</td>
                                        <td id="ui_bulkAdd_way4">-</td>
                                        <td id="ui_bulkAdd_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Add Message</td>
                                        <td id="ui_singleAdd_way1">-</td>
                                        <td id="ui_singleAdd_way2">-</td>
                                        <td id="ui_singleAdd_way3">-</td>
                                        <td id="ui_singleAdd_way4">-</td>
                                        <td id="ui_singleAdd_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Bulk Update Message</td>
                                        <td id="ui_bulkUpdate_way1">-</td>
                                        <td id="ui_bulkUpdate_way2">-</td>
                                        <td id="ui_bulkUpdate_way3">-</td>
                                        <td id="ui_bulkUpdate_way4">-</td>
                                        <td id="ui_bulkUpdate_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Update Message</td>
                                        <td id="ui_singleUpdate_way1">-</td>
                                        <td id="ui_singleUpdate_way2">-</td>
                                        <td id="ui_singleUpdate_way3">-</td>
                                        <td id="ui_singleUpdate_way4">-</td>
                                        <td id="ui_singleUpdate_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Single Delete Message</td>
                                        <td id="ui_singleDelete_way1">-</td>
                                        <td id="ui_singleDelete_way2">-</td>
                                        <td id="ui_singleDelete_way3">-</td>
                                        <td id="ui_singleDelete_way4">-</td>
                                        <td id="ui_singleDelete_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Get Chat Messages</td>
                                        <td id="ui_getChat_way1">-</td>
                                        <td id="ui_getChat_way2">-</td>
                                        <td id="ui_getChat_way3">-</td>
                                        <td id="ui_getChat_way4">-</td>
                                        <td id="ui_getChat_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Get Chat Messages By Index Range</td>
                                        <td id="ui_getChatIndex_way1">-</td>
                                        <td id="ui_getChatIndex_way2">-</td>
                                        <td id="ui_getChatIndex_way3">-</td>
                                        <td id="ui_getChatIndex_way4">-</td>
                                        <td id="ui_getChatIndex_margin">-</td>
                                    </tr>
                                    <tr>
                                        <td>Check Message Exists</td>
                                        <td id="ui_checkExists_way1">-</td>
                                        <td id="ui_checkExists_way2">-</td>
                                        <td id="ui_checkExists_way3">-</td>
                                        <td id="ui_checkExists_way4">-</td>
                                        <td id="ui_checkExists_margin">-</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Overall Best Approach Section -->
                <div class="card" style="margin-top: 20px;">
                    <h2 style="text-align: center; color: #667eea; margin-bottom: 15px;">🏆 Overall Best Approach Recommendation</h2>
                    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #f093fb 100%); border-radius: 10px; color: white;">
                        <h3 style="margin: 0 0 15px 0; font-size: 1.5em;">🎯 Way 4: Two Stores + Web Worker</h3>
                        <p style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">
                            Based on UI Responsiveness Winners (Main Thread Time Only)
                        </p>
                        <div style="display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px;">
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px;"><img src="public/cliq.png" alt="Cliq" style="width: 40px; height: 40px; vertical-align: middle; display: block; margin: 0 auto;"></div>
                                <div style="font-weight: bold;">Best Performance</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">Two-store architecture</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px;">⚡</div>
                                <div style="font-weight: bold;">Most Responsive</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">Web Worker offloading</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px;">💡</div>
                                <div style="font-weight: bold;">Smart Design</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">Composite indexes</div>
                            </div>
                        </div>
                        <div style="margin-top: 25px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                            <p style="margin: 0; font-weight: bold; font-size: 1.1em;">
                                💡 <strong>Why Way 4?</strong> Combines the performance benefits of two-store architecture with the UI responsiveness of Web Workers, 
                                making it the ideal choice
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>📊 Test Summary</h2>
                <div class="test-results">
                    <div class="test-result-item">
                        <span class="test-result-label">Total Chats Added:</span>
                        <span class="test-result-value" id="totalChatsSummary">-</span>
                    </div>
                    <div class="test-result-item">
                        <span class="test-result-label">Total Messages Added:</span>
                        <span class="test-result-value" id="totalMessagesSummary">-</span>
                    </div>
                    <div class="test-result-item">
                        <span class="test-result-label">Messages Loaded per Chat:</span>
                        <span class="test-result-value" id="messagesPerChatSummary">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let performanceChart = null;
        let mainThreadChart = null;
        let way1Results = null;
        let way2Results = null;
        let way3Results = null;
        let way4Results = null;

        let worker = null;

        // Generate realistic message object based on the sample structure
        function generateMessageObject(chatId, messageIndex) {
            const timestamp = Date.now() - Math.random() * 86400000;
            const msguid = `${timestamp}_${Math.floor(Math.random() * 1000000)}`;
            const senderId = Math.floor(Math.random() * 1000000).toString();
            const displayName = `User_${Math.floor(Math.random() * 100)}`;
            
            return {
                chid: chatId,
                ctype: 11,
                detected_language: "en",
                dname: displayName,
                id: msguid,
                language_detection_version: 4,
                lmsgtime: timestamp.toString(),
                lmsguid: `${timestamp}%20${Math.floor(Math.random() * 100000000000)}`,
                mentionmsgid: `${chatId}|${senderId}|${timestamp}`,
                meta: {
                    formattedmsg: [{
                        type: "text",
                        content: `Message ${messageIndex + 1} in chat ${chatId} - ${Math.random().toString(36).substring(7)}`
                    }],
                    mentions: {},
                    usermessagedetails: { themeid: '4' },
                    msg: `Message ${messageIndex + 1} in chat ${chatId} - ${Math.random().toString(36).substring(7)}`,
                    msguid: msguid,
                    mtype: "12",
                    raw: true
                },
                reactions: {},
                revision: 1,
                sender: senderId,
                sequence_id: messageIndex + 1,
                threadmsg: "true",
                time: timestamp.toString()
            };
        }

        // Way 1: Single Transcript Store
        class Way1SingleStore {
            constructor() {
                this.dbName = 'ChatStorageWay1';
                this.dbVersion = 1;
                this.storeName = 'transcriptStore';
                this.db = null;
            }

            async initialize() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => {
                        console.error('Failed to open IndexedDB for Way1');
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        //console.log('✅ Way1 Single Store (Main Thread) initialized');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'chid' });
                            store.createIndex('chid', 'chid', { unique: true });
                        }
                    };
                });
            }

            async addMessage(chatId, message) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    const getRequest = store.get(chatId);
                    
                    getRequest.onsuccess = () => {
                        let chatData = getRequest.result;
                        
                        if (!chatData) {
                            chatData = { chid: chatId, messages: {} };
                        }
                        
                        chatData.messages[message.meta.msguid] = message;
                        
                        const putRequest = store.put(chatData);
                        
                        putRequest.onsuccess = () => {
                            const endTime = performance.now();
                            resolve({
                                success: true,
                                duration: endTime - startTime,
                                messageId: message.meta.msguid
                            });
                        };
                        
                        putRequest.onerror = () => {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: putRequest.error.message
                            });
                        };
                    };
                    
                    getRequest.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: getRequest.error.message
                        });
                    };
                });
            }

            async getChatMessages(chatId, limit = null, strategy = 'default') {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    let messages = [];
                    let totalMessages = 0;
                    
                    switch (strategy) {
                        case 'index_range':
                            // Strategy 1: Index-based range query with time filtering
                            try {
                                const index = store.index('timeIndex');
                                const timeRange = IDBKeyRange.bound(0, Date.now());
                                const indexRequest = index.openCursor(timeRange, 'prev');
                                
                                indexRequest.onsuccess = (event) => {
                                    const cursor = event.target.result;
                                    if (cursor) {
                                        if (cursor.value.chatId === chatId) {
                                            messages.push(cursor.value);
                                            if (limit && messages.length >= limit) {
                                                cursor.continue();
                                                return;
                                            }
                                        }
                                        cursor.continue();
                                    } else {
                                        // Sort by time (newest first) and apply limit
                                        messages = messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                        if (limit && limit > 0) {
                                            messages = messages.slice(0, limit);
                                        }
                                        
                                        const endTime = performance.now();
                                        resolve({
                                            success: true,
                                            duration: endTime - startTime,
                                            messages: messages,
                                            totalMessages: messages.length,
                                            strategy: 'index_range'
                                        });
                                    }
                                };
                                
                                indexRequest.onerror = () => {
                                    const endTime = performance.now();
                                    resolve({
                                        success: false,
                                        duration: endTime - startTime,
                                        error: indexRequest.error.message,
                                        messages: [],
                                        strategy: 'index_range'
                                    });
                                };
                            } catch (error) {
                                // Fallback to default if index doesn't exist
                                this.getChatMessages(chatId, limit, 'default').then(resolve);
                            }
                            break;
                            
                        case 'cursor_batch':
                            // Strategy 2: Cursor-based batching for large datasets
                            const cursorRequest = store.openCursor();
                            let batchSize = 0;
                            const batchLimit = 100;
                            
                            cursorRequest.onsuccess = (event) => {
                                const cursor = event.target.result;
                                if (cursor) {
                                    if (cursor.value.chatId === chatId) {
                                        messages.push(cursor.value);
                                        batchSize++;
                                        
                                        if (batchSize >= batchLimit) {
                                            // Process batch
                                            batchSize = 0;
                                        }
                                        
                                        if (limit && messages.length >= limit) {
                                            cursor.continue();
                                            return;
                                        }
                                    }
                                    cursor.continue();
                                } else {
                                    // Sort by time (newest first) and apply limit
                                    messages = messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                    if (limit && limit > 0) {
                                        messages = messages.slice(0, limit);
                                    }
                                    
                                    const endTime = performance.now();
                                    resolve({
                                        success: true,
                                        duration: endTime - startTime,
                                        messages: messages,
                                        totalMessages: messages.length,
                                        strategy: 'cursor_batch'
                                    });
                                }
                            };
                            
                            cursorRequest.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: cursorRequest.error.message,
                                    messages: [],
                                    strategy: 'cursor_batch'
                                });
                            };
                            break;
                            
                        default:
                            // Default strategy: Original implementation
                            const request = store.get(chatId);
                            
                            request.onsuccess = () => {
                                const chatData = request.result;
                                messages = chatData ? Object.values(chatData.messages || {}) : [];
                                
                                // Sort messages by time (newest first) and apply limit
                                messages = messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                
                                if (limit && limit > 0) {
                                    messages = messages.slice(0, limit);
                                }
                                
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messages: messages,
                                    totalMessages: messages.length,
                                    strategy: 'default'
                                });
                            };
                            
                            request.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: request.error.message,
                                    messages: [],
                                    strategy: 'default'
                                });
                            };
                            break;
                    }
                });
            }

            async updateMessage(chatId, messageId, updatedMessage) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(chatId);
                    
                    request.onsuccess = () => {
                        const chatData = request.result;
                        
                        if (chatData && chatData.messages[messageId]) {
                            chatData.messages[messageId] = { ...chatData.messages[messageId], ...updatedMessage };
                            
                            const putRequest = store.put(chatData);
                            
                            putRequest.onsuccess = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messageId: messageId
                                });
                            };
                            
                            putRequest.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: putRequest.error.message
                                });
                            };
                        } else {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: 'Message not found'
                            });
                        }
                    };
                    
                    request.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: request.error.message
                        });
                    };
                });
            }

            async checkMessageExists(chatId, messageId) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(chatId);
                    
                    request.onsuccess = () => {
                        const chatData = request.result;
                        const exists = chatData && chatData.messages && chatData.messages[messageId];
                        
                        const endTime = performance.now();
                        resolve({
                            success: true,
                            duration: endTime - startTime,
                            exists: exists
                        });
                    };
                    
                    request.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: request.error.message,
                            exists: false
                        });
                    };
                });
            }

            async deleteMessage(chatId, messageId) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(chatId);
                    
                    request.onsuccess = () => {
                        const chatData = request.result;
                        
                        if (chatData && chatData.messages && chatData.messages[messageId]) {
                            delete chatData.messages[messageId];
                            
                            const putRequest = store.put(chatData);
                            
                            putRequest.onsuccess = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messageId: messageId
                                });
                            };
                            
                            putRequest.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: putRequest.error.message
                                });
                            };
                        } else {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: 'Message not found'
                            });
                        }
                    };
                    
                    request.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: request.error.message
                        });
                    };
                });
            }

            async getStats() {
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const chats = request.result;
                        const stats = {
                            totalChats: chats.length,
                            totalMessages: 0,
                            averageMessagesPerChat: 0
                        };
                        
                        chats.forEach(chat => {
                            stats.totalMessages += Object.keys(chat.messages || {}).length;
                        });
                        
                        stats.averageMessagesPerChat = stats.totalChats > 0 ? stats.totalMessages / stats.totalChats : 0;
                        
                        resolve(stats);
                    };
                    
                    request.onerror = () => {
                        resolve({ error: request.error.message });
                    };
                });
            }

            async close() {
                if (this.db) {
                    this.db.close();
                }
            }
        }

        // Way 2: Two Stores
        class Way2TwoStores {
            constructor() {
                this.dbName = 'ChatStorageWay2';
                this.dbVersion = 3;
                this.transcriptStoreName = 'transcriptStore';
                this.messageStoreName = 'messageStore';
                this.db = null;
            }

            async initialize() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => {
                        console.error('Failed to open IndexedDB for Way2');
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                       // console.log('✅ Way2 Two Stores (Main Thread) initialized');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains(this.transcriptStoreName)) {
                            const transcriptStore = db.createObjectStore(this.transcriptStoreName, { keyPath: 'chid' });
                            transcriptStore.createIndex('chid', 'chid', { unique: true });
                        }
                        
                                                    if (!db.objectStoreNames.contains(this.messageStoreName)) {
                                const messageStore = db.createObjectStore(this.messageStoreName, {
                                    keyPath: ['chid', 'meta.msguid']
                                });
                                // Create composite index for efficient range queries
                                messageStore.createIndex('chatid_msgid', ['chid', 'meta.msguid'], { unique: false });
                            }
                    };
                });
            }

            async addMessage(chatId, message) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.transcriptStoreName, this.messageStoreName], 'readwrite');
                    const transcriptStore = transaction.objectStore(this.transcriptStoreName);
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    
                    // Create message object with msguid as direct property for key path
                    const messageForStore = {
                        ...message,
                        msguid: message.meta.msguid
                    };
                    
                    // Add message to message store
                    const messageRequest = messageStore.put(messageForStore);
                    
                    messageRequest.onsuccess = () => {
                        // Update transcript store
                        const transcriptRequest = transcriptStore.get(chatId);
                        
                        transcriptRequest.onsuccess = () => {
                            let chatData = transcriptRequest.result;
                            
                            if (!chatData) {
                                chatData = { chid: chatId, msguids: {} };
                            }
                            
                            // Use object/map for O(1) lookups instead of array
                            if (!chatData.msguids[message.meta.msguid]) {
                                chatData.msguids[message.meta.msguid] = true;
                                
                                const putTranscriptRequest = transcriptStore.put(chatData);
                                
                                putTranscriptRequest.onsuccess = () => {
                                    const endTime = performance.now();
                                    resolve({
                                        success: true,
                                        duration: endTime - startTime,
                                        messageId: message.meta.msguid
                                    });
                                };
                                
                                putTranscriptRequest.onerror = () => {
                                    const endTime = performance.now();
                                    resolve({
                                        success: false,
                                        duration: endTime - startTime,
                                        error: putTranscriptRequest.error.message
                                    });
                                };
                            } else {
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messageId: message.meta.msguid
                                });
                            }
                        };
                        
                        transcriptRequest.onerror = () => {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: transcriptRequest.error.message
                            });
                        };
                    };
                    
                    messageRequest.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: messageRequest.error.message
                        });
                    };
                });
            }

            async getChatMessages(chatId, limit = null, strategy = 'default') {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.transcriptStoreName, this.messageStoreName], 'readonly');
                    const transcriptStore = transaction.objectStore(this.transcriptStoreName);
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    
                    switch (strategy) {
                        case 'parallel_fetch':
                            // Strategy 1: Parallel message fetching with chunking
                            const transcriptRequest1 = transcriptStore.get(chatId);
                            
                            transcriptRequest1.onsuccess = () => {
                                const chatData = transcriptRequest1.result;
                                const messageIds = chatData ? (chatData.msguids || {}) : {};
                                
                                if (Object.keys(messageIds).length === 0) {
                                    const endTime = performance.now();
                                    resolve({
                                        success: true,
                                        duration: endTime - startTime,
                                        messages: [],
                                        totalMessages: 0,
                                        strategy: 'parallel_fetch'
                                    });
                                    return;
                                }
                                
                                const messageIdsArray = Object.keys(messageIds);
                                const limitedMessageIds = limit && limit > 0 ? messageIdsArray.slice(-limit) : messageIdsArray;
                                
                                // Chunk messages for parallel processing
                                const chunkSize = 10;
                                const chunks = [];
                                for (let i = 0; i < limitedMessageIds.length; i += chunkSize) {
                                    chunks.push(limitedMessageIds.slice(i, i + chunkSize));
                                }
                                
                                const messages = [];
                                let completedChunks = 0;
                                
                                chunks.forEach(chunk => {
                                    const chunkMessages = [];
                                    let completedInChunk = 0;
                                    
                                    chunk.forEach(messageId => {
                                        const messageRequest = messageStore.get(messageId);
                                        
                                        messageRequest.onsuccess = () => {
                                            if (messageRequest.result) {
                                                chunkMessages.push(messageRequest.result);
                                            }
                                            completedInChunk++;
                                            
                                            if (completedInChunk === chunk.length) {
                                                messages.push(...chunkMessages);
                                                completedChunks++;
                                                
                                                if (completedChunks === chunks.length) {
                                                    // Sort messages by time (newest first)
                                                    messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                                    
                                                    const endTime = performance.now();
                                                    resolve({
                                                        success: true,
                                                        duration: endTime - startTime,
                                                        messages: messages,
                                                        totalMessages: messages.length,
                                                        strategy: 'parallel_fetch'
                                                    });
                                                }
                                            }
                                        };
                                        
                                        messageRequest.onerror = () => {
                                            completedInChunk++;
                                            if (completedInChunk === chunk.length) {
                                                messages.push(...chunkMessages);
                                                completedChunks++;
                                                
                                                if (completedChunks === chunks.length) {
                                                    const endTime = performance.now();
                                                    resolve({
                                                        success: true,
                                                        duration: endTime - startTime,
                                                        messages: messages,
                                                        totalMessages: messages.length,
                                                        strategy: 'parallel_fetch'
                                                    });
                                                }
                                            }
                                        };
                                    });
                                });
                            };
                            
                            transcriptRequest1.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: transcriptRequest1.error.message,
                                    messages: [],
                                    strategy: 'parallel_fetch'
                                });
                            };
                            break;
                            
                        case 'cursor_optimized':
                            // Strategy 2: Cursor-based optimization for large datasets
                            const transcriptRequest2 = transcriptStore.get(chatId);
                            
                            transcriptRequest2.onsuccess = () => {
                                const chatData = transcriptRequest2.result;
                                const messageIds = chatData ? (chatData.msguids || {}) : {};
                                
                                if (Object.keys(messageIds).length === 0) {
                                    const endTime = performance.now();
                                    resolve({
                                        success: true,
                                        duration: endTime - startTime,
                                        messages: [],
                                        totalMessages: 0,
                                        strategy: 'cursor_optimized'
                                    });
                                    return;
                                }
                                
                                const messageIdsArray = Object.keys(messageIds);
                                const limitedMessageIds = limit && limit > 0 ? messageIdsArray.slice(-limit) : messageIdsArray;
                                
                                // Use cursor for efficient traversal
                                const messages = [];
                                let processedCount = 0;
                                
                                const processNextMessage = (index) => {
                                    if (index >= limitedMessageIds.length) {
                                        // Sort messages by time (newest first)
                                        messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                        
                                        const endTime = performance.now();
                                        resolve({
                                            success: true,
                                            duration: endTime - startTime,
                                            messages: messages,
                                            totalMessages: messages.length,
                                            strategy: 'cursor_optimized'
                                        });
                                        return;
                                    }
                                    
                                    const messageId = limitedMessageIds[index];
                                    const messageRequest = messageStore.get(messageId);
                                    
                                    messageRequest.onsuccess = () => {
                                        if (messageRequest.result) {
                                            messages.push(messageRequest.result);
                                        }
                                        processedCount++;
                                        
                                        // Process next message
                                        processNextMessage(index + 1);
                                    };
                                    
                                    messageRequest.onerror = () => {
                                        processedCount++;
                                        processNextMessage(index + 1);
                                    };
                                };
                                
                                // Start processing
                                processNextMessage(0);
                            };
                            
                            transcriptRequest2.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: transcriptRequest2.error.message,
                                    messages: [],
                                    strategy: 'cursor_optimized'
                                });
                            };
                            break;
                            
                        default:
                            // Default strategy: Original implementation
                            const transcriptRequest = transcriptStore.get(chatId);
                            
                            transcriptRequest.onsuccess = () => {
                                const chatData = transcriptRequest.result;
                                const messageIds = chatData ? (chatData.msguids || {}) : {};
                                
                                if (Object.keys(messageIds).length === 0) {
                                    const endTime = performance.now();
                                    resolve({
                                        success: true,
                                        duration: endTime - startTime,
                                        messages: [],
                                        totalMessages: 0,
                                        strategy: 'default'
                                    });
                                    return;
                                }
                                
                                // Convert object keys to array and apply limit to message IDs (take the last N IDs)
                                const messageIdsArray = Object.keys(messageIds);
                                const limitedMessageIds = limit && limit > 0 ? messageIdsArray.slice(-limit) : messageIdsArray;
                                
                                const messages = [];
                                let completedRequests = 0;
                                
                                limitedMessageIds.forEach(messageId => {
                                    const messageRequest = messageStore.get(messageId);
                                    
                                    messageRequest.onsuccess = () => {
                                        if (messageRequest.result) {
                                            messages.push(messageRequest.result);
                                        }
                                        completedRequests++;
                                        
                                        if (completedRequests === limitedMessageIds.length) {
                                            // Sort messages by time (newest first)
                                            messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                            
                                            const endTime = performance.now();
                                            resolve({
                                                success: true,
                                                duration: endTime - startTime,
                                                messages: messages,
                                                totalMessages: messages.length,
                                                strategy: 'default'
                                            });
                                        }
                                    };
                                    
                                    messageRequest.onerror = () => {
                                        completedRequests++;
                                        if (completedRequests === limitedMessageIds.length) {
                                            const endTime = performance.now();
                                            resolve({
                                                success: true,
                                                duration: endTime - startTime,
                                                messages: messages,
                                                totalMessages: messages.length,
                                                strategy: 'default'
                                            });
                                        }
                                    };
                                });
                            };
                            
                            transcriptRequest.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: transcriptRequest.error.message,
                                    messages: [],
                                    strategy: 'default'
                                });
                            };
                            break;
                    }
                });
            }

            async updateMessage(chatId, messageId, updatedMessage) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.messageStoreName], 'readwrite');
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    
                    // Use composite key [chatId, messageId] for lookup
                    const getRequest = messageStore.get([chatId, messageId]);
                    
                    getRequest.onsuccess = () => {
                        const message = getRequest.result;
                        
                        if (message) {
                            const updatedMsg = { 
                                ...message, 
                                ...updatedMessage,
                                msguid: messageId // Ensure msguid is preserved
                            };
                            
                            const putRequest = messageStore.put(updatedMsg);
                            
                            putRequest.onsuccess = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messageId: messageId
                                });
                            };
                            
                            putRequest.onerror = () => {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: putRequest.error.message
                                });
                            };
                        } else {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: 'Message not found'
                            });
                        }
                    };
                    
                    getRequest.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: getRequest.error.message
                        });
                    };
                });
            }

            async checkMessageExists(chatId, messageId) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.messageStoreName], 'readonly');
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    // Use composite key [chatId, messageId] for lookup
                    const request = messageStore.get([chatId, messageId]);
                    
                    request.onsuccess = () => {
                        const exists = !!request.result;
                        
                        const endTime = performance.now();
                        resolve({
                            success: true,
                            duration: endTime - startTime,
                            exists: exists
                        });
                    };
                    
                    request.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: request.error.message,
                            exists: false
                        });
                    };
                });
            }

            async deleteMessage(chatId, messageId) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.transcriptStoreName, this.messageStoreName], 'readwrite');
                    const transcriptStore = transaction.objectStore(this.transcriptStoreName);
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    
                    // First, remove from message store using composite key
                    const deleteMessageRequest = messageStore.delete([chatId, messageId]);
                    
                    deleteMessageRequest.onsuccess = () => {
                        // Then, remove from transcript store
                        const getTranscriptRequest = transcriptStore.get(chatId);
                        
                        getTranscriptRequest.onsuccess = () => {
                            const chatData = getTranscriptRequest.result;
                            
                            if (chatData && chatData.msguids) {
                                if (chatData.msguids[messageId]) {
                                    delete chatData.msguids[messageId];
                                    
                                    const putTranscriptRequest = transcriptStore.put(chatData);
                                    
                                    putTranscriptRequest.onsuccess = () => {
                                        const endTime = performance.now();
                                        resolve({
                                            success: true,
                                            duration: endTime - startTime,
                                            messageId: messageId
                                        });
                                    };
                                    
                                    putTranscriptRequest.onerror = () => {
                                        const endTime = performance.now();
                                        resolve({
                                            success: false,
                                            duration: endTime - startTime,
                                            error: putTranscriptRequest.error.message
                                        });
                                    };
                                } else {
                                    const endTime = performance.now();
                                    resolve({
                                        success: false,
                                        duration: endTime - startTime,
                                        error: 'Message ID not found in transcript'
                                    });
                                }
                            } else {
                                const endTime = performance.now();
                                resolve({
                                    success: false,
                                    duration: endTime - startTime,
                                    error: 'Chat not found'
                                });
                            }
                        };
                        
                        getTranscriptRequest.onerror = () => {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: getTranscriptRequest.error.message
                            });
                        };
                    };
                    
                    deleteMessageRequest.onerror = () => {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: deleteMessageRequest.error.message
                        });
                    };
                });
            }

            async getStats() {
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.transcriptStoreName], 'readonly');
                    const store = transaction.objectStore(this.transcriptStoreName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const chats = request.result;
                        const stats = {
                            totalChats: chats.length,
                            totalMessages: 0,
                            averageMessagesPerChat: 0
                        };
                        
                        chats.forEach(chat => {
                            stats.totalMessages += Object.keys(chat.msguids || {}).length;
                        });
                        
                        stats.averageMessagesPerChat = stats.totalChats > 0 ? stats.totalMessages / stats.totalChats : 0;
                        
                        resolve(stats);
                    };
                    
                    request.onerror = () => {
                        resolve({ error: request.error.message });
                    };
                });
            }

            async getChatMessagesByIndexRange(chatId, limit = null) {
                const startTime = performance.now();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([this.messageStoreName], 'readonly');
                    const messageStore = transaction.objectStore(this.messageStoreName);
                    
                    try {
                        // Use composite index for efficient range queries
                        const index = messageStore.index('chatid_msgid');
                        
                        // Create range for specific chat - all messages for this chat
                        const range = IDBKeyRange.bound([chatId, 0], [chatId, Infinity]);
                        const cursor = index.openCursor(range, 'prev'); // newest first
                        
                        let messages = [];
                        
                        cursor.onsuccess = (event) => {
                            const cursorResult = event.target.result;
                            if (cursorResult && messages.length < (limit || Infinity)) {
                                messages.push(cursorResult.value);
                                cursorResult.continue();
                            } else {
                                // Sort by time (newest first) and apply limit
                                messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                if (limit && limit > 0) {
                                    messages = messages.slice(0, limit);
                                }
                                
                                const endTime = performance.now();
                                resolve({
                                    success: true,
                                    duration: endTime - startTime,
                                    messages: messages,
                                    totalMessages: messages.length,
                                    strategy: 'composite_index'
                                });
                            }
                        };
                        
                        cursor.onerror = () => {
                            const endTime = performance.now();
                            resolve({
                                success: false,
                                duration: endTime - startTime,
                                error: cursor.error.message,
                                messages: [],
                                strategy: 'composite_index'
                            });
                        };
                    } catch (error) {
                        const endTime = performance.now();
                        resolve({
                            success: false,
                            duration: endTime - startTime,
                            error: error.message,
                            messages: [],
                            strategy: 'composite_index'
                        });
                    }
                });
            }

            async close() {
                if (this.db) {
                    this.db.close();
                }
            }
        }

        async function destroyAllDatabases() {
            const databases = ['ChatStorageWay1', 'ChatStorageWay2', 'ChatStorageWay3', 'ChatStorageWay4'];
            
            for (const dbName of databases) {
                try {
                    await new Promise((resolve, reject) => {
                        const request = indexedDB.deleteDatabase(dbName);
                        request.onsuccess = () => {
                            //console.log(`🗑️ Deleted database: ${dbName}`);
                            resolve();
                        };
                        request.onerror = () => {
                            console.log(`❌ Failed to delete database: ${dbName}`);
                            resolve();
                        };
                    });
                } catch (error) {
                    console.log(`❌ Error deleting database ${dbName}:`, error);
                }
            }
            
            
        }

        function generateTestData(numChats, messagesPerChat) {
            const testData = [];
            
            for (let i = 0; i < numChats; i++) {
                const chatId = `CT_${Math.floor(Math.random() * 1000000000)}_${Math.floor(Math.random() * 100000000)}`;
                const chatMessages = [];
                
                for (let j = 0; j < messagesPerChat; j++) {
                    chatMessages.push(generateMessageObject(chatId, j));
                }
                
                testData.push({ chatId, messages: chatMessages });
            }
            
            return testData;
        }

        async function runTest() {
            const numChats = parseInt(document.getElementById('numChats').value);
            const messagesPerChat = parseInt(document.getElementById('messagesPerChat').value);
            const testOperations = document.getElementById('testOperations').value;

            showLoading();
            
            try {
                const messagesToLoad = parseInt(document.getElementById('messagesToLoad').value) || 40;
                const clearPreviousDB = document.getElementById('clearPreviousDB').checked;
                
                // Clear all databases first only if the checkbox is checked
        
                 await destroyAllDatabases();
                
                
                // Test Way 1
                //console.log('🚀 Starting Way 1 Test...');
                document.querySelector('#loading h3').textContent = 'Testing Way 1: Single Store (Main Thread)...';
                way1Results = await runSingleTest('way1', numChats, messagesPerChat, messagesToLoad, testOperations);
                
                // Clear Way 1 database before testing Way 2 (if checkbox is checked)
                if (clearPreviousDB) {
                    await new Promise((resolve) => {
                        const request = indexedDB.deleteDatabase('ChatStorageWay1');
                        request.onsuccess = () => {
                            //console.log('🗑️ Cleared Way 1 database');
                            resolve();
                        };
                        request.onerror = () => resolve();
                    });
                }
                
                // Test Way 2
                //console.log('🚀 Starting Way 2 Test...');
                document.querySelector('#loading h3').textContent = 'Testing Way 2: Two Stores (Main Thread)...';
                way2Results = await runSingleTest('way2', numChats, messagesPerChat, messagesToLoad, testOperations);
                
                // Clear Way 2 database before testing Way 3 (if checkbox is checked)
                if (clearPreviousDB) {
                    await new Promise((resolve) => {
                        const request = indexedDB.deleteDatabase('ChatStorageWay2');
                        request.onsuccess = () => {
                            //console.log('🗑️ Cleared Way 2 database');
                            resolve();
                        };
                        request.onerror = () => resolve();
                    });
                }
                
                // Test Way 3 (Web Worker)
                //console.log('🚀 Starting Way 3 Test...');
                document.querySelector('#loading h3').textContent = 'Testing Way 3: Way 1 + Web Worker...';
                way3Results = await runSingleTest('way3', numChats, messagesPerChat, messagesToLoad, testOperations);
                
                // Clear Way 3 database before testing Way 4 (if checkbox is checked)
                if (clearPreviousDB) {
                    await new Promise((resolve) => {
                        const request = indexedDB.deleteDatabase('ChatStorageWay3');
                        request.onsuccess = () => {
                            //console.log('🗑️ Cleared Way 3 database');
                            resolve();
                        };
                        request.onerror = () => resolve();
                    });
                }
                
                // Also clear Way 4 database to ensure clean state (if checkbox is checked)
                if (clearPreviousDB) {
                    await new Promise((resolve) => {
                        const request = indexedDB.deleteDatabase('ChatStorageWay4');
                        request.onsuccess = () => {
                            //console.log('🗑️ Cleared Way 4 database (pre-test)');
                            console.log('🔍 Debug: Way 4 database deletion successful');
                            resolve();
                        };
                        request.onerror = () => {
                            //console.log('🔍 Debug: Way 4 database deletion failed');
                            resolve();
                        };
                    });
                }
                
                // Test Way 4 (Two Stores Web Worker)
                //console.log('🚀 Starting Way 4 Test...');
                document.querySelector('#loading h3').textContent = 'Testing Way 4: Way 2 + Web Worker...';
                way4Results = await runSingleTest('way4', numChats, messagesPerChat, messagesToLoad, testOperations);
                
                // Clear Way 4 database after testing (if checkbox is checked)
                if (clearPreviousDB) {
                    await new Promise((resolve) => {
                        const request = indexedDB.deleteDatabase('ChatStorageWay4');
                        request.onsuccess = () => {
                            //console.log('🗑️ Cleared Way 4 database');
                            resolve();
                        };
                        request.onerror = () => resolve();
                    });
                }
                
                // Display comparison results
                displayComparisonResults(way1Results, way2Results, way3Results, way4Results);
                
            } catch (error) {
                console.error('Test error:', error);
                alert('Error running test: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        async function runSingleTest(approach, numChats, messagesPerChat, messagesToLoad, testOperations) {
            // Initialize the selected store
            let store;
            switch (approach) {
                case 'way1':
                    store = new Way1SingleStore();
                    break;
                case 'way2':
                    store = new Way2TwoStores();
                    break;
                case 'way3':
                    store = new Way3SingleStoreWebWorker();
                    break;
                case 'way4':
                    store = new Way4TwoStoresWebWorker();
                    break;

            }

            await store.initialize();

            const testData = generateTestData(numChats, messagesPerChat);
            const results = {
                // Bulk operations (initial data loading)
                bulkAddMessage: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                bulkUpdateMessage: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                
                // Single operations (real-time usage)
                singleAddMessage: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                singleUpdateMessage: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                singleDeleteMessage: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                
                // Read operations
                getChatMessages: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                getChatMessagesByIndexRange: { durations: [], total: 0, workerDurations: [], totalWorker: 0 },
                checkMessageExists: { durations: [], total: 0, workerDurations: [], totalWorker: 0 }
            };

            // Phase 1: Bulk Add all messages (initial data loading)
            //console.log(`📝 Bulk Adding ${numChats * messagesPerChat} messages for ${approach}...`);
            let totalMessages = 0;
            let processedMessages = 0;
            
            for (const { chatId, messages } of testData) {
                totalMessages += messages.length;
                for (const message of messages) {
                    const result = await store.addMessage(chatId, message);
                    if (result.success) {
                        results.bulkAddMessage.durations.push(result.duration);
                        results.bulkAddMessage.total += result.duration;
                        if (result.workerDuration) {
                            results.bulkAddMessage.workerDurations.push(result.workerDuration);
                            results.bulkAddMessage.totalWorker += result.workerDuration;
                        }
                    }
                    processedMessages++;
                    
                    if (processedMessages % 1000 === 0) {
                        const progress = ((processedMessages / totalMessages) * 20).toFixed(1);
                        document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Bulk Adding Messages... ${progress}%`;
                    }
                }
            }

            // Phase 2: Test operations based on selection
            if (testOperations === 'all' || testOperations === 'bulk' || testOperations === 'read') {
                // Test getChatMessages
                //console.log(`📖 Testing Get Chat Messages for ${approach}...`);
                let processedReads = 0;
                for (const { chatId } of testData) {
                    const result = await store.getChatMessages(chatId, messagesToLoad);
                    if (result.success) {
                        results.getChatMessages.durations.push(result.duration);
                        results.getChatMessages.total += result.duration;
                        if (result.workerDuration) {
                            results.getChatMessages.workerDurations.push(result.workerDuration);
                            results.getChatMessages.totalWorker += result.workerDuration;
                        }
                    }
                    processedReads++;
                    
                    const progress = (20 + (processedReads / numChats) * 20).toFixed(1);
                    document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Reading Messages... ${progress}%`;
                }

                // Test getChatMessagesByIndexRange for Way 2 and Way 4
                if (approach === 'way2' || approach === 'way4') {
                    //console.log(`📖 Testing Get Chat Messages By Index Range for ${approach}...`);
                    let processedIndexReads = 0;
                    for (const { chatId } of testData) {
                        const result = await store.getChatMessagesByIndexRange(chatId, messagesToLoad);
                        if (result.success) {
                            results.getChatMessagesByIndexRange.durations.push(result.duration);
                            results.getChatMessagesByIndexRange.total += result.duration;
                            if (result.workerDuration) {
                                results.getChatMessagesByIndexRange.workerDurations.push(result.workerDuration);
                                results.getChatMessagesByIndexRange.totalWorker += result.workerDuration;
                            }
                        }
                        processedIndexReads++;
                        
                        const progress = (30 + (processedIndexReads / numChats) * 10).toFixed(1);
                        document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Reading Messages By Index Range... ${progress}%`;
                    }
                }

                // Test checkMessageExists
                //console.log(`🔍 Testing Check Message Exists for ${approach}...`);
                let processedChecks = 0;
                for (const { chatId, messages } of testData) {
                    for (let i = 0; i < Math.min(10, messages.length); i++) {
                        const messageId = messages[i].meta.msguid;
                        const result = await store.checkMessageExists(chatId, messageId);
                        if (result.success) {
                            results.checkMessageExists.durations.push(result.duration);
                            results.checkMessageExists.total += result.duration;
                            if (result.workerDuration) {
                                results.checkMessageExists.workerDurations.push(result.workerDuration);
                                results.checkMessageExists.totalWorker += result.workerDuration;
                            }
                        }
                        processedChecks++;
                        
                        if (processedChecks % 100 === 0) {
                            const progress = (40 + (processedChecks / (numChats * 10)) * 20).toFixed(1);
                            document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Checking Messages... ${progress}%`;
                        }
                    }
                }
            }

            if (testOperations === 'all' || testOperations === 'bulk') {
                // Test bulk updateMessage
               // console.log(`✏️ Testing Bulk Update Messages for ${approach}...`);
                let processedUpdates = 0;
                for (const { chatId, messages } of testData) {
                    for (let i = 0; i < Math.min(5, messages.length); i++) {
                        const messageId = messages[i].meta.msguid;
                        const updatedMessage = {
                            meta: {
                                ...messages[i].meta,
                                msg: `BULK_UPDATED: ${messages[i].meta.msg}`
                            }
                        };
                        const result = await store.updateMessage(chatId, messageId, updatedMessage);
                        if (result.success) {
                            results.bulkUpdateMessage.durations.push(result.duration);
                            results.bulkUpdateMessage.total += result.duration;
                            if (result.workerDuration) {
                                results.bulkUpdateMessage.workerDurations.push(result.workerDuration);
                                results.bulkUpdateMessage.totalWorker += result.workerDuration;
                            }
                        }
                        processedUpdates++;
                        
                        if (processedUpdates % 100 === 0) {
                            const progress = (60 + (processedUpdates / (numChats * 5)) * 20).toFixed(1);
                            document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Bulk Updating Messages... ${progress}%`;
                        }
                    }
                }
            }

            // Phase 3: Test single operations (real-time usage)
            if (testOperations === 'all' || testOperations === 'single') {
                //console.log(`🚀 Testing Single Operations for ${approach}...`);
                
                // Test single add message
                //console.log(`➕ Testing Single Add Message for ${approach}...`);
                for (let i = 0; i < 100; i++) { // Test 100 single adds
                    const chatId = testData[Math.floor(Math.random() * testData.length)].chatId;
                    const newMessage = generateMessageObject(chatId, 999 + i);
                    const result = await store.addMessage(chatId, newMessage);
                    if (result.success) {
                        results.singleAddMessage.durations.push(result.duration);
                        results.singleAddMessage.total += result.duration;
                        if (result.workerDuration) {
                            results.singleAddMessage.workerDurations.push(result.workerDuration);
                            results.singleAddMessage.totalWorker += result.workerDuration;
                        }
                    }
                    
                    if (i % 20 === 0) {
                        const progress = (80 + (i / 100) * 10).toFixed(1);
                        document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Single Add Messages... ${progress}%`;
                    }
                }

                // Test single update message
               // console.log(`✏️ Testing Single Update Message for ${approach}...`);
                for (let i = 0; i < 100; i++) { // Test 100 single updates
                    const randomChat = testData[Math.floor(Math.random() * testData.length)];
                    const randomMessage = randomChat.messages[Math.floor(Math.random() * randomChat.messages.length)];
                    const messageId = randomMessage.meta.msguid;
                    const updatedMessage = {
                        meta: {
                            ...randomMessage.meta,
                            msg: `SINGLE_UPDATED: ${randomMessage.meta.msg}`
                        }
                    };
                    const result = await store.updateMessage(randomChat.chatId, messageId, updatedMessage);
                    if (result.success) {
                        results.singleUpdateMessage.durations.push(result.duration);
                        results.singleUpdateMessage.total += result.duration;
                        if (result.workerDuration) {
                            results.singleUpdateMessage.workerDurations.push(result.workerDuration);
                            results.singleUpdateMessage.totalWorker += result.workerDuration;
                        }
                    }
                    
                    if (i % 20 === 0) {
                        const progress = (90 + (i / 100) * 10).toFixed(1);
                        document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Single Update Messages... ${progress}%`;
                    }
                }

                // Test single delete message (if delete method exists)
                //console.log(`🗑️ Testing Single Delete Message for ${approach}...`);
                for (let i = 0; i < 50; i++) { // Test 50 single deletes
                    const randomChat = testData[Math.floor(Math.random() * testData.length)];
                    const randomMessage = randomChat.messages[Math.floor(Math.random() * randomChat.messages.length)];
                    const messageId = randomMessage.meta.msguid;
                    
                    // Only test delete if the method exists
                    if (store.deleteMessage) {
                        const result = await store.deleteMessage(randomChat.chatId, messageId);
                        if (result && result.success) {
                            results.singleDeleteMessage.durations.push(result.duration);
                            results.singleDeleteMessage.total += result.duration;
                            if (result.workerDuration) {
                                results.singleDeleteMessage.workerDurations.push(result.workerDuration);
                                results.singleDeleteMessage.totalWorker += result.workerDuration;
                            }
                        }
                    }
                    
                    if (i % 10 === 0) {
                        const progress = (95 + (i / 50) * 5).toFixed(1);
                        document.querySelector('#loading h3').textContent = `${approach.toUpperCase()}: Single Delete Messages... ${progress}%`;
                    }
                }
            }

            // Calculate averages
            //console.log(`🔍 Debug: Final results for ${approach}:`, results);
            const finalResults = {
                // Bulk operations
                bulkAddMessage: {
                    average: results.bulkAddMessage.durations.length > 0 ? results.bulkAddMessage.total / results.bulkAddMessage.durations.length : 0,
                    count: results.bulkAddMessage.durations.length,
                    workerDuration: results.bulkAddMessage.workerDurations.length > 0 ? results.bulkAddMessage.totalWorker / results.bulkAddMessage.workerDurations.length : 0
                },
                bulkUpdateMessage: {
                    average: results.bulkUpdateMessage.durations.length > 0 ? results.bulkUpdateMessage.total / results.bulkUpdateMessage.durations.length : 0,
                    count: results.bulkUpdateMessage.durations.length,
                    workerDuration: results.bulkUpdateMessage.workerDurations.length > 0 ? results.bulkUpdateMessage.totalWorker / results.bulkUpdateMessage.workerDurations.length : 0
                },
                
                // Single operations
                singleAddMessage: {
                    average: results.singleAddMessage.durations.length > 0 ? results.singleAddMessage.total / results.singleAddMessage.durations.length : 0,
                    count: results.singleAddMessage.durations.length,
                    workerDuration: results.singleAddMessage.workerDurations.length > 0 ? results.singleAddMessage.totalWorker / results.singleAddMessage.workerDurations.length : 0
                },
                singleUpdateMessage: {
                    average: results.singleUpdateMessage.durations.length > 0 ? results.singleUpdateMessage.total / results.singleUpdateMessage.durations.length : 0,
                    count: results.singleUpdateMessage.durations.length,
                    workerDuration: results.singleUpdateMessage.workerDurations.length > 0 ? results.singleUpdateMessage.totalWorker / results.singleUpdateMessage.workerDurations.length : 0
                },
                singleDeleteMessage: {
                    average: results.singleDeleteMessage.durations.length > 0 ? results.singleDeleteMessage.total / results.singleDeleteMessage.durations.length : 0,
                    count: results.singleDeleteMessage.durations.length,
                    workerDuration: results.singleDeleteMessage.workerDurations.length > 0 ? results.singleDeleteMessage.totalWorker / results.singleDeleteMessage.workerDurations.length : 0
                },
                
                // Read operations
                getChatMessages: {
                    average: results.getChatMessages.durations.length > 0 ? results.getChatMessages.total / results.getChatMessages.durations.length : 0,
                    count: results.getChatMessages.durations.length,
                    workerDuration: results.getChatMessages.workerDurations.length > 0 ? results.getChatMessages.totalWorker / results.getChatMessages.workerDurations.length : 0
                },
                getChatMessagesByIndexRange: {
                    average: results.getChatMessagesByIndexRange.durations.length > 0 ? results.getChatMessagesByIndexRange.total / results.getChatMessagesByIndexRange.durations.length : 0,
                    count: results.getChatMessagesByIndexRange.durations.length,
                    workerDuration: results.getChatMessagesByIndexRange.workerDurations.length > 0 ? results.getChatMessagesByIndexRange.totalWorker / results.getChatMessagesByIndexRange.workerDurations.length : 0
                },
                checkMessageExists: {
                    average: results.checkMessageExists.durations.length > 0 ? results.checkMessageExists.total / results.checkMessageExists.durations.length : 0,
                    count: results.checkMessageExists.durations.length,
                    workerDuration: results.checkMessageExists.workerDurations.length > 0 ? results.checkMessageExists.totalWorker / results.checkMessageExists.workerDurations.length : 0
                }
            };

            // Get stats
            const stats = await store.getStats();
            //console.log(`📊 Final Stats for ${approach}:`, stats);

            await store.close();
            
            return { results: finalResults, stats };
        }

        function createComparisonChart(way1Results, way2Results, way3Results, way4Results) {
            // console.log('🔍 Creating chart with data:');
            // console.log('🔍 Way 1:', way1Results);
            // console.log('🔍 Way 2:', way2Results);
            // console.log('🔍 Way 3:', way3Results);
            // console.log('🔍 Way 4:', way4Results);
            
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            if (performanceChart) {
                performanceChart.destroy();
            }

            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [
                        'Bulk Add', 'Single Add', 
                        'Bulk Update', 'Single Update', 'Single Delete',
                        'Get Chat Messages', 'Get Chat Messages By Index Range', 'Check Message Exists'
                    ],
                    datasets: [{
                        label: 'Way 1: Single Store (Main Thread)',
                        data: [
                            way1Results.bulkAddMessage.average,
                            way1Results.singleAddMessage.average,
                            way1Results.bulkUpdateMessage.average,
                            way1Results.singleUpdateMessage.average,
                            way1Results.singleDeleteMessage.average,
                            way1Results.getChatMessages.average,
                            way1Results.getChatMessagesByIndexRange.average,
                            way1Results.checkMessageExists.average
                        ],
                        backgroundColor: '#667eea',
                        borderColor: '#667eea',
                        borderWidth: 2
                    }, {
                        label: 'Way 2: Two Stores (Main Thread)',
                        data: [
                            way2Results.bulkAddMessage.average,
                            way2Results.singleAddMessage.average,
                            way2Results.bulkUpdateMessage.average,
                            way2Results.singleUpdateMessage.average,
                            way2Results.singleDeleteMessage.average,
                            way2Results.getChatMessages.average,
                            way2Results.getChatMessagesByIndexRange.average,
                            way2Results.checkMessageExists.average
                        ],
                        backgroundColor: '#f093fb',
                        borderColor: '#f093fb',
                        borderWidth: 2
                    }, {
                        label: 'Way 3: Way 1 + Web Worker',
                        data: [
                            way3Results.bulkAddMessage.average,
                            way3Results.singleAddMessage.average,
                            way3Results.bulkUpdateMessage.average,
                            way3Results.singleUpdateMessage.average,
                            way3Results.singleDeleteMessage.average,
                            way3Results.getChatMessages.average,
                            way3Results.getChatMessagesByIndexRange.average,
                            way3Results.checkMessageExists.average
                        ],
                        backgroundColor: '#a8edea',
                        borderColor: '#a8edea',
                        borderWidth: 2
                    }, {
                        label: 'Way 4: Way 2 + Web Worker',
                        data: [
                            way4Results.bulkAddMessage.average,
                            way4Results.singleAddMessage.average,
                            way4Results.bulkUpdateMessage.average,
                            way4Results.singleUpdateMessage.average,
                            way4Results.singleDeleteMessage.average,
                            way4Results.getChatMessages.average,
                            way4Results.getChatMessagesByIndexRange.average,
                            way4Results.checkMessageExists.average
                        ],
                        backgroundColor: '#fed6e3',
                        borderColor: '#fed6e3',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Performance Comparison Chart (Time taken in main thread and worker thread combined)'
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    // console.log('🔍 Tooltip callback triggered:', context);
                                    const datasetIndex = context[0].datasetIndex;
                                    const dataIndex = context[0].dataIndex;
                                    const way = context[0].dataset.label;
                                    
                                    // console.log('🔍 Dataset index:', datasetIndex, 'Data index:', dataIndex, 'Way:', way);
                                    
                                    // Check if this is a Web Worker approach (Way 3 or Way 4)
                                    if (way.includes('Web Worker') || way.includes('Way 3') || way.includes('Way 4')) {
                                        // console.log('🔍 This is a Web Worker approach');
                                        const wayData = datasetIndex === 2 ? way3Results : way4Results;
                                        const categories = [
                                            'bulkAddMessage', 'singleAddMessage', 'bulkUpdateMessage', 'singleUpdateMessage', 
                                            'singleDeleteMessage', 'getChatMessages', 'getChatMessagesByIndexRange', 'checkMessageExists'
                                        ];
                                        const category = categories[dataIndex];
                                        
                                        // console.log('🔍 Category:', category, 'Way data:', wayData);
                                        
                                        if (wayData && wayData.results && wayData.results[category]) {
                                            const mainThread = wayData.results[category].average || 0;
                                            const worker = wayData.results[category].workerDuration || 0;
                                            
                                            // console.log('🔍 Main thread:', mainThread, 'Worker:', worker);
                                            
                                            if (mainThread > 0 && worker > 0) {
                                                const communicationOverhead = mainThread - worker;
                                                const percentageFree = ((communicationOverhead / mainThread) * 100).toFixed(1);
                                                
                                                // console.log('🔍 Communication overhead:', communicationOverhead, 'Percentage free:', percentageFree);
                                                
                                                return [
                                                    '',
                                                    `Total Time: ${mainThread.toFixed(2)}ms`,
                                                    `Worker: ${worker.toFixed(2)}ms`,
                                                    `Main Thread Free: ${communicationOverhead.toFixed(2)}ms`,
                                                    `UI Responsiveness: ${percentageFree}%`
                                                ];
                                            } else {
                                                // console.log('🔍 Missing data - Main thread:', mainThread, 'Worker:', worker);
                                                return [
                                                    '',
                                                    `Total Time: ${mainThread.toFixed(2)}ms`,
                                                    `Worker: ${worker > 0 ? worker.toFixed(2) + 'ms' : 'Not measured'}`,
                                                    `Main Thread Free: ${worker > 0 ? (mainThread - worker).toFixed(2) + 'ms' : 'Unknown'}`
                                                ];
                                            }
                                        } else {
                                            // console.log('🔍 No way data found for category:', category);
                                        }
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        function createMainThreadChart(way1Results, way2Results, way3Results, way4Results) {
            // console.log('🔍 Creating main thread chart with data:');
            // console.log('🔍 Way 1:', way1Results);
            // console.log('🔍 Way 2:', way2Results);
            // console.log('🔍 Way 3:', way3Results);
            // console.log('🔍 Way 4:', way4Results);
            
            const ctx = document.getElementById('mainThreadChart').getContext('2d');
            
            if (mainThreadChart) {
                mainThreadChart.destroy();
            }

            
            mainThreadChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [
                        'Bulk Add', 'Single Add', 
                        'Bulk Update', 'Single Update', 'Single Delete',
                        'Get Chat Messages', 'Get Chat Messages By Index Range', 'Check Message Exists'
                    ],
                    datasets: [{
                        label: 'Way 1: Single Store (Main Thread)',
                        data: [
                            way1Results.bulkAddMessage.average,
                            way1Results.singleAddMessage.average,
                            way1Results.bulkUpdateMessage.average,
                            way1Results.singleUpdateMessage.average,
                            way1Results.singleDeleteMessage.average,
                            way1Results.getChatMessages.average,
                            way1Results.getChatMessagesByIndexRange.average,
                            way1Results.checkMessageExists.average
                        ],
                        backgroundColor: '#667eea',
                        borderColor: '#667eea',
                        borderWidth: 2
                    }, {
                        label: 'Way 2: Two Stores (Main Thread)',
                        data: [
                             way2Results.bulkAddMessage.average,
                            way2Results.singleAddMessage.average,
                            way2Results.bulkUpdateMessage.average,
                            way2Results.singleUpdateMessage.average,
                            way2Results.singleDeleteMessage.average,
                            way2Results.getChatMessages.average,
                            way2Results.getChatMessagesByIndexRange.average,
                            way2Results.checkMessageExists.average
                        ],
                        backgroundColor: '#f093fb',
                        borderColor: '#f093fb',
                        borderWidth: 2
                    }, {
                        label: 'Way 3: Way 1 + Web Worker (Main Thread Only)',
                        data: [
                            way3Results.bulkAddMessage.workerDuration ?  way3Results.bulkAddMessage.average - way3Results.bulkAddMessage.workerDuration : way3Results.bulkAddMessage.average,
                            way3Results.singleAddMessage.workerDuration ? way3Results.singleAddMessage.average - way3Results.singleAddMessage.workerDuration : way3Results.singleAddMessage.average,
                            way3Results.bulkUpdateMessage.workerDuration ? way3Results.bulkUpdateMessage.average - way3Results.bulkUpdateMessage.workerDuration : way3Results.bulkUpdateMessage.average,
                            way3Results.singleUpdateMessage.workerDuration ? way3Results.singleUpdateMessage.average - way3Results.singleUpdateMessage.workerDuration : way3Results.singleUpdateMessage.average,
                            way3Results.singleDeleteMessage.workerDuration ? way3Results.singleDeleteMessage.average - way3Results.singleDeleteMessage.workerDuration : way3Results.singleDeleteMessage.average,
                            way3Results.getChatMessages.workerDuration ? way3Results.getChatMessages.average - way3Results.getChatMessages.workerDuration : way3Results.getChatMessages.average,
                            way3Results.getChatMessagesByIndexRange.workerDuration ? way3Results.getChatMessagesByIndexRange.average - way3Results.getChatMessagesByIndexRange.workerDuration : way3Results.getChatMessagesByIndexRange.average,
                            way3Results.checkMessageExists.workerDuration ? way3Results.checkMessageExists.average - way3Results.checkMessageExists.workerDuration : way3Results.checkMessageExists.average
                        ],
                        backgroundColor: '#a8edea',
                        borderColor: '#a8edea',
                        borderWidth: 2
                    }, {
                        label: 'Way 4: Way 2 + Web Worker (Main Thread Only)',
                        data: [
                            way4Results.bulkAddMessage.workerDuration ? way4Results.bulkAddMessage.average - way4Results.bulkAddMessage.workerDuration : way4Results.bulkAddMessage.average,
                            way4Results.singleAddMessage.workerDuration ? way4Results.singleAddMessage.average - way4Results.singleAddMessage.workerDuration : way4Results.singleAddMessage.average,
                            way4Results.bulkUpdateMessage.workerDuration ? way4Results.bulkUpdateMessage.average - way4Results.bulkUpdateMessage.workerDuration : way4Results.bulkUpdateMessage.average,
                            way4Results.singleUpdateMessage.workerDuration ? way4Results.singleUpdateMessage.average - way4Results.singleUpdateMessage.workerDuration : way4Results.singleUpdateMessage.average,
                            way4Results.singleDeleteMessage.workerDuration ? way4Results.singleDeleteMessage.average - way4Results.singleDeleteMessage.workerDuration : way4Results.singleDeleteMessage.average,
                            way4Results.getChatMessages.workerDuration ? way4Results.getChatMessages.average - way4Results.getChatMessages.workerDuration : way4Results.getChatMessages.average,
                            way4Results.getChatMessagesByIndexRange.workerDuration ? way4Results.getChatMessagesByIndexRange.average - way4Results.getChatMessagesByIndexRange.workerDuration : way4Results.getChatMessagesByIndexRange.average,
                            way4Results.checkMessageExists.workerDuration ? way4Results.checkMessageExists.average - way4Results.checkMessageExists.workerDuration : way4Results.checkMessageExists.average
                        ],
                        backgroundColor: '#fed6e3',
                        borderColor: '#fed6e3',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Main Thread Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Performance Comparison Chart (Time taken in main thread only)'
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const datasetIndex = context[0].datasetIndex;
                                    const dataIndex = context[0].dataIndex;
                                    const way = context[0].dataset.label;
                                    
                                    // Check if this is a Web Worker approach (Way 3 or Way 4)
                                    if (way.includes('Web Worker') || way.includes('Way 3') || way.includes('Way 4')) {
                                        const wayData = datasetIndex === 2 ? way3Results : way4Results;
                                        const categories = [
                                            'bulkAddMessage', 'singleAddMessage', 'bulkUpdateMessage', 'singleUpdateMessage', 
                                            'singleDeleteMessage', 'getChatMessages', 'getChatMessagesByIndexRange', 'checkMessageExists'
                                        ];
                                        const category = categories[dataIndex];
                                        
                                        if (wayData && wayData.results && wayData.results[category]) {
                                            const mainThread = wayData.results[category].average || 0;
                                            const worker = wayData.results[category].workerDuration || 0;
                                            
                                            if (mainThread > 0 && worker > 0) {
                                                const communicationOverhead = mainThread - worker;
                                                const percentageFree = ((communicationOverhead / mainThread) * 100).toFixed(1);
                                                
                                                return [
                                                    '',
                                                    `Main Thread Blocked: ${mainThread.toFixed(2)}ms`,
                                                    `Worker Execution: ${worker.toFixed(2)}ms`,
                                                    `Communication Overhead: ${communicationOverhead.toFixed(2)}ms`,
                                                    `UI Responsiveness: ${percentageFree}%`
                                                ];
                                            } else {
                                                return [
                                                    '',
                                                    `Main Thread Blocked: ${mainThread.toFixed(2)}ms`,
                                                    `Worker: ${worker > 0 ? worker.toFixed(2) + 'ms' : 'Not measured'}`
                                                ];
                                            }
                                        }
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }



        // Single Store with Web Worker (Way 3)
        class Way3SingleStoreWebWorker {
            constructor() {
                this.dbName = 'ChatStorageWay3';
                this.dbVersion = 1;
                this.transcriptStoreName = 'transcriptStore';
                this.db = null;
                this.worker = null;
                this.messageId = 0;
            }

            async initialize() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        
                        // Create Web Worker for all operations
                        const workerCode = `
                            let db = null;
                            let transcriptStoreName = 'transcriptStore';
                            
                            self.onmessage = async function(e) {
                                const { type, id, data } = e.data;
                                
                                try {
                                    switch(type) {
                                        case 'initialize':
                                            await initializeDB();
                                            self.postMessage({ id, success: true });
                                            break;
                                        case 'addMessage':
                                            const addResult = await addMessage(data.chatId, data.message);
                                            self.postMessage({ id, success: true, result: addResult });
                                            break;
                                        case 'getChatMessages':
                                            const getResult = await getChatMessages(data.chatId, data.limit);
                                            self.postMessage({ id, success: true, result: getResult });
                                            break;
                                        case 'updateMessage':
                                            const updateResult = await updateMessage(data.chatId, data.messageId, data.updatedMessage);
                                            self.postMessage({ id, success: true, result: updateResult });
                                            break;
                                        case 'deleteMessage':
                                            const deleteResult = await deleteMessage(data.chatId, data.messageId);
                                            self.postMessage({ id, success: true, result: deleteResult });
                                            break;
                                        case 'checkMessageExists':
                                            const checkResult = await checkMessageExists(data.chatId, data.messageId);
                                            self.postMessage({ id, success: true, result: checkResult });
                                            break;
                                        case 'getStats':
                                            const statsResult = await getStats();
                                            self.postMessage({ id, success: true, result: statsResult });
                                            break;
                                    }
                                } catch (error) {
                                    self.postMessage({ id, success: false, error: error.message });
                                }
                            };
                            
                            async function initializeDB() {
                                return new Promise((resolve, reject) => {
                                    const request = indexedDB.open('ChatStorageWay3', 1);
                                    
                                    request.onerror = () => reject(request.error);
                                    request.onsuccess = () => {
                                        db = request.result;
                                        resolve();
                                    };
                                    
                                    request.onupgradeneeded = (event) => {
                                        const db = event.target.result;
                                        if (!db.objectStoreNames.contains(transcriptStoreName)) {
                                            const transcriptStore = db.createObjectStore(transcriptStoreName, { keyPath: 'chatId' });
                                            transcriptStore.createIndex('chatId', 'chatId', { unique: true });
                                        }
                                    };
                                });
                            }
                            
                            async function addMessage(chatId, message) {
                                const startTime = performance.now();
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readwrite');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        let chatData = request.result;
                                        
                                        if (!chatData) {
                                            chatData = { chatId: chatId, messages: {} };
                                        }
                                        
                                        // Store message with msguid as key
                                        chatData.messages[message.meta.msguid] = message;
                                        
                                        const putRequest = store.put(chatData);
                                        
                                        putRequest.onsuccess = () => {
                                            const endTime = performance.now();
                                            const workerDuration = endTime - startTime;
                                            resolve({
                                                success: true,
                                                duration: workerDuration,
                                                workerDuration: workerDuration,
                                                messageId: message.meta.msguid
                                            });
                                        };
                                        
                                        putRequest.onerror = () => reject(putRequest.error);
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function getChatMessages(chatId, limit = null) {
                                const startTime = performance.now();
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readonly');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        const chatData = request.result;
                                        
                                        if (!chatData || !chatData.messages) {
                                            const endTime = performance.now();
                                            const workerDuration = endTime - startTime;
                                            resolve({
                                                success: true,
                                                duration: workerDuration,
                                                workerDuration: workerDuration,
                                                messages: [],
                                                totalMessages: 0
                                            });
                                            return;
                                        }
                                        
                                        let messages = Object.values(chatData.messages);
                                        
                                        // Sort by time (newest first)
                                        messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                        
                                        // Apply limit if specified
                                        if (limit && limit > 0) {
                                            messages = messages.slice(0, limit);
                                        }
                                        
                                        const endTime = performance.now();
                                        const workerDuration = endTime - startTime;
                                        resolve({
                                            success: true,
                                            duration: workerDuration,
                                            workerDuration: workerDuration,
                                            messages: messages,
                                            totalMessages: messages.length
                                        });
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function updateMessage(chatId, messageId, updatedMessage) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readwrite');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        const chatData = request.result;
                                        
                                        if (chatData && chatData.messages && chatData.messages[messageId]) {
                                            // Update the message
                                            chatData.messages[messageId] = { ...chatData.messages[messageId], ...updatedMessage };
                                            
                                            const putRequest = store.put(chatData);
                                            
                                            putRequest.onsuccess = () => {
                                                const endTime = performance.now();
                                                const workerDuration = endTime - startTime;
                                                resolve({
                                                    success: true,
                                                    duration: workerDuration,
                                                    workerDuration: workerDuration,
                                                    messageId: messageId
                                                });
                                            };
                                            
                                            putRequest.onerror = () => reject(putRequest.error);
                                        } else {
                                            reject(new Error('Message not found'));
                                        }
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function deleteMessage(chatId, messageId) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readwrite');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        const chatData = request.result;
                                        
                                        if (chatData && chatData.messages && chatData.messages[messageId]) {
                                            delete chatData.messages[messageId];
                                            
                                            const putRequest = store.put(chatData);
                                            
                                            putRequest.onsuccess = () => {
                                                const endTime = performance.now();
                                                resolve({
                                                    success: true,
                                                    duration: endTime - startTime,
                                                    workerDuration: endTime - startTime,
                                                    messageId: messageId
                                                });
                                            };
                                            
                                            putRequest.onerror = () => reject(putRequest.error);
                                        } else {
                                            const endTime = performance.now();
                                            const workerDuration = endTime - startTime;
                                            resolve({
                                                success: true,
                                                duration: workerDuration,
                                                workerDuration: workerDuration,
                                                messageId: messageId
                                            });
                                        }
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function checkMessageExists(chatId, messageId) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readonly');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        const chatData = request.result;
                                        const exists = chatData && chatData.messages && chatData.messages[messageId];
                                        
                                        const endTime = performance.now();
                                        const workerDuration = endTime - startTime;
                                        resolve({
                                            success: true,
                                            duration: workerDuration,
                                            workerDuration: workerDuration,
                                            exists: exists
                                        });
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function getStats() {
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readonly');
                                    const store = transaction.objectStore(transcriptStoreName);
                                    
                                    const request = store.getAll();
                                    
                                    request.onsuccess = () => {
                                        const chats = request.result || [];
                                        const stats = {
                                            totalChats: chats.length,
                                            totalMessages: 0,
                                            averageMessagesPerChat: 0
                                        };
                                        
                                        chats.forEach(chat => {
                                            stats.totalMessages += Object.keys(chat.messages || {}).length;
                                        });
                                        
                                        stats.averageMessagesPerChat = stats.totalChats > 0 ? stats.totalMessages / stats.totalChats : 0;
                                        
                                        resolve(stats);
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                        `;
                        
                        const blob = new Blob([workerCode], { type: 'application/javascript' });
                        this.worker = new Worker(URL.createObjectURL(blob));
                        
                        this.worker.onmessage = (e) => {
                            const { id, success, result, error } = e.data;
                            if (this.pendingRequests[id]) {
                                if (success) {
                                    this.pendingRequests[id].resolve(result);
                                } else {
                                    this.pendingRequests[id].reject(new Error(error));
                                }
                                delete this.pendingRequests[id];
                            }
                        };
                        
                        this.pendingRequests = {};
                        
                        // Initialize the worker
                        this.sendMessage('initialize').then(() => {
                            console.log('✅ Way3 Way 1 + Web Worker initialized');
                            resolve();
                        }).catch(reject);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.transcriptStoreName)) {
                            const transcriptStore = db.createObjectStore(this.transcriptStoreName, { keyPath: 'chatId' });
                            transcriptStore.createIndex('chatId', 'chatId', { unique: true });
                        }
                    };
                });
            }

            sendMessage(type, data = {}) {
                return new Promise((resolve, reject) => {
                    const id = ++this.messageId;
                    this.pendingRequests[id] = { resolve, reject };
                    this.worker.postMessage({ type, id, data });
                });
            }

            // All operations go through Web Worker with main thread timing
            async addMessage(chatId, message) {
                const startTime = performance.now();
                const result = await this.sendMessage('addMessage', { chatId, message });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async getChatMessages(chatId, limit = null) {
                const startTime = performance.now();
                const result = await this.sendMessage('getChatMessages', { chatId, limit });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async updateMessage(chatId, messageId, updatedMessage) {
                const startTime = performance.now();
                const result = await this.sendMessage('updateMessage', { chatId, messageId, updatedMessage });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async deleteMessage(chatId, messageId) {
                const startTime = performance.now();
                const result = await this.sendMessage('deleteMessage', { chatId, messageId });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async checkMessageExists(chatId, messageId) {
                const startTime = performance.now();
                const result = await this.sendMessage('checkMessageExists', { chatId, messageId });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async getStats() {
                return this.sendMessage('getStats');
            }

            async close() {
                if (this.worker) {
                    this.worker.terminate();
                }
                if (this.db) {
                    this.db.close();
                }
            }
        }

        // Two Stores with Web Worker (Way 4)
        class Way4TwoStoresWebWorker {
            constructor() {
                this.dbName = 'ChatStorageWay4';
                this.dbVersion = 6;
                this.transcriptStoreName = 'transcriptStore';
                this.messageStoreName = 'messageStore';
                this.db = null;
                this.worker = null;
                this.messageId = 0;
            }

            async initialize() {
                return new Promise((resolve, reject) => {
                    // Don't open database in main thread - let Web Worker handle it
                    this.db = null;
                    
                    // Create Web Worker for all operations
                        const workerCode = `
                            let db = null;
                            let transcriptStoreName = 'transcriptStore';
                            let messageStoreName = 'messageStore';
                            
                            self.onmessage = async function(e) {
                                const { type, id, data } = e.data;
                                
                                try {
                                    switch(type) {
                                        case 'initialize':
                                            await initializeDB();
                                            self.postMessage({ id, success: true });
                                            break;
                                        case 'addMessage':
                                            const addResult = await addMessage(data.chatId, data.message);
                                            self.postMessage({ id, success: true, result: addResult });
                                            break;
                                        case 'getChatMessages':
                                            const getResult = await getChatMessages(data.chatId, data.limit);
                                            self.postMessage({ id, success: true, result: getResult });
                                            break;
                                        case 'updateMessage':
                                            const updateResult = await updateMessage(data.chatId, data.messageId, data.updatedMessage);
                                            self.postMessage({ id, success: true, result: updateResult });
                                            break;
                                        case 'deleteMessage':
                                            const deleteResult = await deleteMessage(data.chatId, data.messageId);
                                            self.postMessage({ id, success: true, result: deleteResult });
                                            break;
                                        case 'checkMessageExists':
                                            const checkResult = await checkMessageExists(data.chatId, data.messageId);
                                            self.postMessage({ id, success: true, result: checkResult });
                                            break;
                                        case 'getStats':
                                            const statsResult = await getStats();
                                            self.postMessage({ id, success: true, result: statsResult });
                                            break;
                                        case 'getChatMessagesByIndexRange':
                                            const getIndexResult = await getChatMessagesByIndexRange(data.chatId, data.limit);
                                            self.postMessage({ id, success: true, result: getIndexResult });
                                            break;
                                    }
                                } catch (error) {
                                    self.postMessage({ id, success: false, error: error.message });
                                }
                            };
                            
                            async function initializeDB() {
                                return new Promise((resolve, reject) => {
                                    //console.log('🔍 Debug: Web Worker attempting to open database with version 5');
                                    const request = indexedDB.open('ChatStorageWay4', 6);
                                    
                                    request.onerror = () => {
                                        console.log('🔍 Debug: Web Worker database open error:', request.error);
                                        reject(request.error);
                                    };
                                    request.onsuccess = () => {
                                        db = request.result;
                                        //console.log('🔍 Debug: Web Worker database version:', db.version);
                                        //console.log('🔍 Debug: Web Worker object stores:', db.objectStoreNames);
                                        resolve();
                                    };
                                    
                                    request.onupgradeneeded = (event) => {
                                        console.log('🔍 Debug: Web Worker onupgradeneeded fired!');
                                        const db = event.target.result;
                                        //console.log('🔍 Debug: Creating object stores and indexes...');
                                        if (!db.objectStoreNames.contains(transcriptStoreName)) {
                                            const transcriptStore = db.createObjectStore(transcriptStoreName, { keyPath: 'chid' });
                                            transcriptStore.createIndex('chid', 'chid', { unique: true });
                                            //console.log('🔍 Debug: Created transcriptStore');
                                        }
                                                                                if (!db.objectStoreNames.contains(messageStoreName)) {
                                            const messageStore = db.createObjectStore(messageStoreName, {
                                                keyPath: ['chid', 'meta.msguid']
                                            });
                                            // Create composite index for efficient range queries
                                            messageStore.createIndex('chatid_msgid', ['chid', 'meta.msguid'], { unique: false });
                                            //console.log('🔍 Debug: Created messageStore with composite primary key and index');
                                        }
                                    };
                                });
                            }
                            
                            async function addMessage(chatId, message) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName, messageStoreName], 'readwrite');
                                    const transcriptStore = transaction.objectStore(transcriptStoreName);
                                    const messageStore = transaction.objectStore(messageStoreName);
                                    
                                    // Create message object with msguid at top level for messageStore
                                    const messageForStore = { ...message };
                                    if (message.meta && message.meta.msguid) {
                                        messageForStore.msguid = message.meta.msguid;
                                    }
                                    
                                    // Add message to messageStore
                                    const messageRequest = messageStore.put(messageForStore);
                                    
                                    messageRequest.onsuccess = () => {
                                        // Update transcriptStore
                                        const transcriptRequest = transcriptStore.get(chatId);
                                        
                                        transcriptRequest.onsuccess = () => {
                                            let chatData = transcriptRequest.result;
                                            
                                            if (!chatData) {
                                                chatData = { chid: chatId, msguids: {} };
                                            }
                                            
                                            // Use map for O(1) operations
                                            chatData.msguids[message.meta.msguid] = true;
                                            
                                            const putRequest = transcriptStore.put(chatData);
                                            
                                            putRequest.onsuccess = () => {
                                                const endTime = performance.now();
                                                const workerDuration = endTime - startTime;
                                                resolve({
                                                    success: true,
                                                    duration: workerDuration,
                                                    workerDuration: workerDuration,
                                                    messageId: message.meta.msguid
                                                });
                                            };
                                            
                                            putRequest.onerror = () => reject(putRequest.error);
                                        };
                                        
                                        transcriptRequest.onerror = () => reject(transcriptRequest.error);
                                    };
                                    
                                    messageRequest.onerror = () => reject(messageRequest.error);
                                });
                            }
                            
                            async function getChatMessages(chatId, limit = null) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName, messageStoreName], 'readonly');
                                    const transcriptStore = transaction.objectStore(transcriptStoreName);
                                    const messageStore = transaction.objectStore(messageStoreName);
                                    
                                    const transcriptRequest = transcriptStore.get(chatId);
                                            
                                    transcriptRequest.onsuccess = () => {
                                        const chatData = transcriptRequest.result;
                                                
                                        if (!chatData || !chatData.msguids) {
                                                    const endTime = performance.now();
                                                    resolve({
                                                        success: true,
                                                        duration: endTime - startTime,
                                                        messages: [],
                                                totalMessages: 0
                                                    });
                                                    return;
                                                }
                                                
                                        // Convert map keys to array and apply limit
                                        let messageIds = Object.keys(chatData.msguids);
                                        
                                        if (limit && limit > 0) {
                                            messageIds = messageIds.slice(-limit); // Get last N messages
                                        }
                                        
                                        if (messageIds.length === 0) {
                                                                    const endTime = performance.now();
                                                                    resolve({
                                                                        success: true,
                                                                        duration: endTime - startTime,
                                                    messages: [],
                                                totalMessages: 0
                                                    });
                                                    return;
                                                }
                                                
                                        // Fetch messages from messageStore
                                                const messages = [];
                                        let completed = 0;
                                        
                                        messageIds.forEach(messageId => {
                                                    const messageRequest = messageStore.get(messageId);
                                                    
                                                    messageRequest.onsuccess = () => {
                                                        if (messageRequest.result) {
                                                            messages.push(messageRequest.result);
                                                        }
                                                completed++;
                                                
                                                if (completed === messageIds.length) {
                                                    // Sort by time (newest first)
                                                            messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                                            
                                                            const endTime = performance.now();
                                                            const workerDuration = endTime - startTime;
                                                            resolve({
                                                                success: true,
                                                                duration: workerDuration,
                                                                workerDuration: workerDuration,
                                                                messages: messages,
                                                        totalMessages: messages.length
                                                            });
                                                        }
                                                    };
                                                    
                                                    messageRequest.onerror = () => {
                                                completed++;
                                                if (completed === messageIds.length) {
                                                            const endTime = performance.now();
                                                            const workerDuration = endTime - startTime;
                                                            resolve({
                                                                success: true,
                                                                duration: workerDuration,
                                                                workerDuration: workerDuration,
                                                                messages: messages,
                                                        totalMessages: messages.length
                                                            });
                                                        }
                                                    };
                                                });
                                            };
                                            
                                    transcriptRequest.onerror = () => reject(transcriptRequest.error);
                                });
                            }
                            
                            async function getChatMessagesByIndexRange(chatId, limit = null) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([messageStoreName], 'readonly');
                                    const messageStore = transaction.objectStore(messageStoreName);
                                    
                                    try {
                                        // Use composite index for efficient range queries
                                        const index = messageStore.index('chatid_msgid');
                                        
                                        // Create range for specific chat - all messages for this chat
                                        const range = IDBKeyRange.bound([chatId, 0], [chatId, Infinity]);
                                        const cursor = index.openCursor(range, 'prev'); // newest first
                                        
                                        let messages = [];
                                        
                                        cursor.onsuccess = (event) => {
                                            const cursorResult = event.target.result;
                                            if (cursorResult && messages.length < (limit || Infinity)) {
                                                messages.push(cursorResult.value);
                                                cursorResult.continue();
                                            } else {
                                                // Sort by time (newest first) and apply limit
                                                messages.sort((a, b) => parseInt(b.time) - parseInt(a.time));
                                                if (limit && limit > 0) {
                                                    messages = messages.slice(0, limit);
                                                }
                                                
                                                const endTime = performance.now();
                                                const workerDuration = endTime - startTime;
                                                resolve({
                                                    success: true,
                                                    duration: workerDuration,
                                                    workerDuration: workerDuration,
                                                    messages: messages,
                                                    totalMessages: messages.length,
                                                    strategy: 'composite_index'
                                                });
                                            }
                                        };
                                        
                                        cursor.onerror = () => {
                                            const endTime = performance.now();
                                            resolve({
                                                success: false,
                                                duration: endTime - startTime,
                                                error: cursor.error.message,
                                                messages: [],
                                                strategy: 'composite_index'
                                            });
                                        };
                                    } catch (error) {
                                        const endTime = performance.now();
                                        resolve({
                                            success: false,
                                            duration: endTime - startTime,
                                            error: error.message,
                                            messages: [],
                                            strategy: 'composite_index'
                                        });
                                    }
                                });
                            }
                            
                            async function updateMessage(chatId, messageId, updatedMessage) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([messageStoreName], 'readwrite');
                                    const messageStore = transaction.objectStore(messageStoreName);
                                    
                                    // Use composite key [chatId, messageId] for lookup
                                    const request = messageStore.get([chatId, messageId]);
                                    
                                    request.onsuccess = () => {
                                        if (request.result) {
                                            // Ensure msguid is preserved at top level
                                            const messageForStore = { ...request.result, ...updatedMessage };
                                            if (updatedMessage.meta && updatedMessage.meta.msguid) {
                                                messageForStore.msguid = updatedMessage.meta.msguid;
                                            }
                                            
                                            const putRequest = messageStore.put(messageForStore);
                                            
                                            putRequest.onsuccess = () => {
                                                const endTime = performance.now();
                                                resolve({
                                                    success: true,
                                                    duration: endTime - startTime,
                                                    workerDuration: endTime - startTime,
                                                    messageId: messageId
                                                });
                                            };
                                            
                                            putRequest.onerror = () => reject(putRequest.error);
                                        } else {
                                            reject(new Error('Message not found'));
                                        }
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function deleteMessage(chatId, messageId) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName, messageStoreName], 'readwrite');
                                    const transcriptStore = transaction.objectStore(transcriptStoreName);
                                    const messageStore = transaction.objectStore(messageStoreName);
                                    
                                    // Delete from messageStore using composite key
                                    const messageRequest = messageStore.delete([chatId, messageId]);
                                    
                                    messageRequest.onsuccess = () => {
                                        // Remove from transcriptStore
                                        const transcriptRequest = transcriptStore.get(chatId);
                                        
                                        transcriptRequest.onsuccess = () => {
                                            const chatData = transcriptRequest.result;
                                            
                                            if (chatData && chatData.msguids && chatData.msguids[messageId]) {
                                                delete chatData.msguids[messageId];
                                                
                                                const putRequest = transcriptStore.put(chatData);
                                                
                                                putRequest.onsuccess = () => {
                                                    const endTime = performance.now();
                                                    const workerDuration = endTime - startTime;
                                                    resolve({
                                                        success: true,
                                                        duration: workerDuration,
                                                        workerDuration: workerDuration,
                                                        messageId: messageId
                                                    });
                                                };
                                                
                                                putRequest.onerror = () => reject(putRequest.error);
                                            } else {
                                                const endTime = performance.now();
                                                resolve({
                                                    success: true,
                                                    duration: endTime - startTime,
                                                    workerDuration: endTime - startTime,
                                                    messageId: messageId
                                                });
                                            }
                                        };
                                        
                                        transcriptRequest.onerror = () => reject(transcriptRequest.error);
                                    };
                                    
                                    messageRequest.onerror = () => reject(messageRequest.error);
                                });
                            }
                            
                            async function checkMessageExists(chatId, messageId) {
                                const startTime = performance.now();
                                
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readonly');
                                    const transcriptStore = transaction.objectStore(transcriptStoreName);
                                    const request = transcriptStore.get(chatId);
                                    
                                    request.onsuccess = () => {
                                        const chatData = request.result;
                                        const exists = chatData && chatData.msguids && chatData.msguids[messageId];
                                        
                                        const endTime = performance.now();
                                        const workerDuration = endTime - startTime;
                                        resolve({
                                            success: true,
                                            duration: workerDuration,
                                            workerDuration: workerDuration,
                                            exists: exists
                                        });
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                            
                            async function getStats() {
                                return new Promise((resolve, reject) => {
                                    const transaction = db.transaction([transcriptStoreName], 'readonly');
                                    const transcriptStore = transaction.objectStore(transcriptStoreName);
                                    const request = transcriptStore.getAll();
                                    
                                    request.onsuccess = () => {
                                        const chats = request.result;
                                        const stats = {
                                            totalChats: chats.length,
                                            totalMessages: 0,
                                            averageMessagesPerChat: 0
                                        };
                                        
                                        chats.forEach(chat => {
                                            stats.totalMessages += Object.keys(chat.msguids || {}).length;
                                        });
                                        
                                        stats.averageMessagesPerChat = stats.totalChats > 0 ? stats.totalMessages / stats.totalChats : 0;
                                        
                                        resolve(stats);
                                    };
                                    
                                    request.onerror = () => reject(request.error);
                                });
                            }
                        `;
                        
                        const blob = new Blob([workerCode], { type: 'application/javascript' });
                        this.worker = new Worker(URL.createObjectURL(blob));
                        
                        this.worker.onmessage = (e) => {
                            const { id, success, result, error } = e.data;
                            if (this.pendingRequests[id]) {
                                if (success) {
                                    this.pendingRequests[id].resolve(result);
                                } else {
                                    this.pendingRequests[id].reject(new Error(error));
                                }
                                delete this.pendingRequests[id];
                            }
                        };
                        
                        this.pendingRequests = {};
                        
                        // Initialize the worker
                        this.sendMessage('initialize').then(() => {
                            console.log('✅ Way4 Way 2 + Web Worker initialized');
                            resolve();
                        }).catch(reject);
                    
                });
            }

            sendMessage(type, data = {}) {
                return new Promise((resolve, reject) => {
                    const id = ++this.messageId;
                    this.pendingRequests[id] = { resolve, reject };
                    this.worker.postMessage({ type, id, data });
                });
            }

            // All operations go through Web Worker with main thread timing
            async addMessage(chatId, message) {
                const startTime = performance.now();
                const result = await this.sendMessage('addMessage', { chatId, message });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async getChatMessages(chatId, limit = null) {
                const startTime = performance.now();
                const result = await this.sendMessage('getChatMessages', { chatId, limit });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async updateMessage(chatId, messageId, updatedMessage) {
                const startTime = performance.now();
                const result = await this.sendMessage('updateMessage', { chatId, messageId, updatedMessage });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async deleteMessage(chatId, messageId) {
                const startTime = performance.now();
                const result = await this.sendMessage('deleteMessage', { chatId, messageId });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async checkMessageExists(chatId, messageId) {
                const startTime = performance.now();
                const result = await this.sendMessage('checkMessageExists', { chatId, messageId });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - ( result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async getStats() {
                return this.sendMessage('getStats');
            }

            async getChatMessagesByIndexRange(chatId, limit = null) {
                const startTime = performance.now();
                const result = await this.sendMessage('getChatMessagesByIndexRange', { chatId, limit });
                const endTime = performance.now();
                const mainThreadDuration = endTime - startTime;
                return {
                    ...result,
                    duration: mainThreadDuration,
                    mainThreadDuration: mainThreadDuration - (result.workerDuration || 0),
                    workerDuration: result.workerDuration || 0
                };
            }

            async close() {
                if (this.worker) {
                    this.worker.terminate();
                }
                if (this.db) {
                    this.db.close();
                }
            }
        }




        function displayComparisonResults(way1Data, way2Data, way3Data, way4Data) {
            document.getElementById('results').style.display = 'block';
            
            // Update summary information
            document.getElementById('totalChatsSummary').textContent = parseInt(document.getElementById('numChats').value);
            document.getElementById('totalMessagesSummary').textContent = parseInt(document.getElementById('numChats').value) * parseInt(document.getElementById('messagesPerChat').value);
            document.getElementById('messagesPerChatSummary').textContent = parseInt(document.getElementById('messagesToLoad').value) || 40;
            
            // Create both charts
            createComparisonChart(way1Data.results, way2Data.results, way3Data.results, way4Data.results);
            createMainThreadChart(way1Data.results, way2Data.results, way3Data.results, way4Data.results);
            
            // Populate winner table
            populateWinnerTable(way1Data, way2Data, way3Data, way4Data);
        }

        function populateWinnerTable(way1Data, way2Data, way3Data, way4Data) {
            // Store current results globally for tooltip access
            window.currentResults = { way1: way1Data, way2: way2Data, way3: way3Data, way4: way4Data };
            
            const categories = [
                { key: 'bulkAddMessage', id: 'bulkAdd' },
                { key: 'singleAddMessage', id: 'singleAdd' },
                { key: 'bulkUpdateMessage', id: 'bulkUpdate' },
                { key: 'singleUpdateMessage', id: 'singleUpdate' },
                { key: 'singleDeleteMessage', id: 'singleDelete' },
                { key: 'getChatMessages', id: 'getChat' },
                { key: 'getChatMessagesByIndexRange', id: 'getChatIndex' },
                { key: 'checkMessageExists', id: 'checkExists' }
            ];

            categories.forEach(category => {
                // Get total time values (for Table 1: Overall Performance)
                const way1Total = way1Data.results[category.key].average;
                const way2Total = way2Data.results[category.key].average;
                const way3Total = way3Data.results[category.key].average;
                const way4Total = way4Data.results[category.key].average;

                // Get main thread time values (for Table 2: UI Responsiveness)
                const way1Main = way1Data.results[category.key].workerDuration ? way1Data.results[category.key].average - way1Data.results[category.key].workerDuration : way1Data.results[category.key].average;
                const way2Main = way2Data.results[category.key].workerDuration ? way2Data.results[category.key].average - way2Data.results[category.key].workerDuration : way2Data.results[category.key].average;
                const way3Main =  way3Data.results[category.key].workerDuration ? way3Data.results[category.key].average - way3Data.results[category.key].workerDuration : way3Data.results[category.key].average;
                const way4Main = way4Data.results[category.key].workerDuration ? way4Data.results[category.key].average - way4Data.results[category.key].workerDuration : way4Data.results[category.key].average;

                // Debug logging
                // console.log(`Category: ${category.key}`);
                // console.log(`Total Time - Way 1: ${way1Total}, Way 2: ${way2Total}, Way 3: ${way3Total}, Way 4: ${way4Total}`);
                // console.log(`Main Thread - Way 1: ${way1Main}, Way 2: ${way2Main}, Way 3: ${way3Main}, Way 4: ${way4Main}`);

                // Special handling for getChatMessagesByIndexRange
                if (category.key === 'getChatMessagesByIndexRange') {
                    // Way 1 and Way 3 don't have this method
                    updateWinnerCell(`overall_${category.id}_way1`, 0, false); // Not applicable
                    updateWinnerCell(`overall_${category.id}_way2`, way2Total, way2Total < way4Total);
                    updateWinnerCell(`overall_${category.id}_way3`, 0, false); // Not applicable
                    updateWinnerCell(`overall_${category.id}_way4`, way4Total, way4Total < way2Total);
                    
                    updateWinnerCell(`ui_${category.id}_way1`, 0, false); // Not applicable
                    updateWinnerCell(`ui_${category.id}_way2`, way2Main, way2Main < way4Main);
                    updateWinnerCell(`ui_${category.id}_way3`, 0, false); // Not applicable
                    updateWinnerCell(`ui_${category.id}_way4`, way4Main, way4Main < way2Main);
                    const sortedValues = [...[way2Main, way4Main]].sort((a, b) => a - b);
                        const secondBest = sortedValues[1] ;
                        const winnerValue = sortedValues[0];
                        const margin = calculateWinningMargin(winnerValue, secondBest);
                        updateMarginCell(`ui_${category.id}_margin`, margin, winnerValue, secondBest);
                } else {
                    // Table 1: Overall Performance (Total Time)
                    const totalValues = [way1Total, way2Total, way3Total, way4Total];
                    const totalWinners = findWinnerRobust(totalValues);
                    
                    if (totalWinners.length > 0) {
                        const winnerIndex = totalWinners[0];
                        const winnerValue = totalValues[winnerIndex];
                        
                        // Update all cells
                        updateWinnerCell(`overall_${category.id}_way1`, way1Total, winnerIndex === 0);
                        updateWinnerCell(`overall_${category.id}_way2`, way2Total, winnerIndex === 1);
                        updateWinnerCell(`overall_${category.id}_way3`, way3Total, winnerIndex === 2);
                        updateWinnerCell(`overall_${category.id}_way4`, way4Total, winnerIndex === 3);
                        
                        // Find the second best for margin calculation
                        const sortedValues = [...totalValues].sort((a, b) => a - b);
                        const secondBest = sortedValues[1];
                        const margin = calculateWinningMargin(winnerValue, secondBest);
                        updateMarginCell(`overall_${category.id}_margin`, margin, winnerValue, secondBest);
                    }

                    // Table 2: UI Responsiveness (Main Thread Only)
                    const mainThreadValues = [way1Main, way2Main, way3Main, way4Main];
                    const mainThreadWinners = findWinnerRobust(mainThreadValues);
                    const way1TotalValues = [way1Total, way2Total, way3Total, way4Total];
                    
                    
                    if (mainThreadWinners.length > 0) {
                        const winnerIndex = mainThreadWinners[0];
                        const winnerValue = mainThreadValues[winnerIndex];
                        
                        // Update all cells
                        updateWinnerCell(`ui_${category.id}_way1`, way1Main, winnerIndex === 0);
                        updateWinnerCell(`ui_${category.id}_way2`, way2Main, winnerIndex === 1);
                        updateWinnerCell(`ui_${category.id}_way3`, way3Main, winnerIndex === 2);
                        updateWinnerCell(`ui_${category.id}_way4`, way4Main, winnerIndex === 3);
                        
                        // Find the second best for margin calculation
                        const sortedValues = [...way1TotalValues].sort((a, b) => a - b);
                        const secondBest = sortedValues[0];
                        const margin = calculateWinningMargin(winnerValue, secondBest);
                        updateMarginCell(`ui_${category.id}_margin`, margin, winnerValue, secondBest);
                    }
                }
            });
        }

        function updateWinnerCell(cellId, value, isWinner) {
            const cell = document.getElementById(cellId);
            if (!cell) return;

            if (value === 0) {
                cell.className = 'neutral';
                cell.textContent = '-';
            } else if (isWinner) {
                cell.className = 'winner-cell';
                cell.textContent = `${value.toFixed(2)}ms`;
            } else {
                cell.className = 'loser-cell';
                cell.textContent = `${value.toFixed(2)}ms`;
            }

            // Add tooltip for Web Worker approaches to show timing breakdown
            if (cellId.includes('worker_') && (cellId.includes('way3') || cellId.includes('way4'))) {
                const way = cellId.includes('way3') ? 'way3' : 'way4';
                const category = cellId.split('_')[1]; // Extract category (bulkAdd, singleAdd, etc.)
                
                // Find the corresponding data to get worker duration
                let tooltipText = `${value.toFixed(2)}ms`;
                
                // Try to get worker duration from the results data
                if (window.currentResults && window.currentResults[way] && window.currentResults[way].results) {
                    const categoryData = window.currentResults[way].results[category];
                    if (categoryData && categoryData.workerDuration) {
                        const workerTime = categoryData.workerDuration;
                        const communicationOverhead = value - workerTime;
                        const percentageFree = ((communicationOverhead / value) * 100).toFixed(1);
                        
                        tooltipText = `${value.toFixed(2)}ms\nWorker: ${workerTime.toFixed(2)}ms\nMain Thread Free: ${percentageFree}%`;
                    }
                }
                
                cell.title = tooltipText;
            }
        }



        function updateMarginCell(cellId, margin, winnerValue, loserValue) {
            const cell = document.getElementById(cellId);
            if (!cell) return;

            if (margin === 0 || winnerValue === 0 || loserValue === 0) {
                cell.className = 'margin-cell';
                cell.textContent = '-';
            } else {
                cell.className = 'margin-cell winner';
                cell.textContent = `${margin}% faster`;
            }
        }

        function findWinner(values) {
            // Filter out zero values and find the minimum
            const validValues = values.filter(v => v > 0);
            if (validValues.length === 0) return [];
            
            const minValue = Math.min(...validValues);
            
            // Find all indices that have the minimum value (winners)
            const winners = values.map((value, index) => 
                value > 0 && Math.abs(value - minValue) < 0.01 ? index : -1
            ).filter(index => index !== -1);
            
            // If multiple winners, just pick the first one to ensure there's always exactly one winner
            if (winners.length > 1) {
                return [winners[0]];
            }
            
            // If no winners found (shouldn't happen), return the first valid value
            if (winners.length === 0 && validValues.length > 0) {
                return [values.findIndex(v => v > 0)];
            }
            
            return winners;
        }

        // Alternative winner detection that always returns exactly one winner when there's valid data
        function findWinnerRobust(values) {
            const validValues = values.filter(v => v > 0);
            if (validValues.length === 0) return [];
            
            // Always return exactly one winner - the one with the lowest value
            const minValue = Math.min(...validValues);
            const winnerIndex = values.findIndex(v => v > 0 && v === minValue);
            
            return [winnerIndex];
        }

        // Calculate winning margin percentage
        function calculateWinningMargin(winnerValue, loserValue) {
            if (winnerValue <= 0 || loserValue <= 0) return 0;
            
            // Calculate percentage improvement
            const difference = loserValue - winnerValue;
            const percentage = (difference / loserValue) * 100;
            
            return Math.round(percentage * 100) / 100; // Round to 2 decimal places
        }

        // Removed toggle functions - no longer needed with separate tables



        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function clearResults() {
            document.getElementById('results').style.display = 'none';
            if (performanceChart) {
                performanceChart.destroy();
                performanceChart = null;
            }
            if (mainThreadChart) {
                mainThreadChart.destroy();
                mainThreadChart = null;
            }
            way1Results = null;
            way2Results = null;
            way3Results = null;
            way4Results = null;
            
            // Clear winner table
            clearWinnerTable();
        }

        function clearWinnerTable() {
            const cells = document.querySelectorAll('[id^="overall_"], [id^="ui_"]');
            cells.forEach(cell => {
                cell.className = '';
                cell.textContent = '-';
            });
        }
    </script>
</body>
</html>
